# 类和对象  

## 当我们编写额如下代码的时候, 我们会如何来称呼这个Person呢? 

```javascript
function Person() {

}
var p1 = new Person()
var p2 = new Person()
```

- 在JS中Person应该被称之为是一个构造函数;
- 从很多面向对象语言过来的开发者, 也习惯称之为类, 因为类可以帮助我们创建出来对象p1, p2;
- 如果从面向对象的编程范式角度来看, Person 确实是可以称之为类的;

## 面向对象的特性 -继承

- 面向对象有三大特性: 封装, 继承, 多态 

> 封装: 我们前面将属性和方法封装到一个类中, 可以称之为 封装的过程;
>> 编写类的过程称之为 一个封装的过程
> 继承: 继承是面向对象中非常重要的, 不仅仅可以减少重复代码的数量, 也是多态前提;

1. 重复利用一些代码(对代码的复用)
2. 继承是多态的前提

> 多态: 不同的对象在执行时表现出不同的形态;

## 继承是做什么呢?

- 继承可以帮助我们将重复的代码和逻辑抽取到父类中, 子类只需要直接继承过来使用即可
- JavaScript当中如何实现继承呢? 

> 先了解 JavaScript原型链的机制;
> 再利用原型链的机制实现一下继承


## 借用构造函数继承

- 为了解决原型链继承中存在的问题, 开发人员提供了一种新的技术: constructor stealing (有很多名称: 借用构造函数 或者 称之为 经典继承 或者 称之为伪造对象)

> steal 是偷窃, 剽窃 的意思, 但是这里可以翻译成借用;

## 寄生组合式继承

- 我们来回顾下之前提出的比较理想的组合继承 

> 组合继承是比较理想的继承方式, 但是存在两个问题:
> 问题一: 构造函数会被调用两次: 一次在创建子类型原型对象的时候, 一次在创建子类型实例的时候 
> 问题二: 父类型中的属性会有两份: 一份在原型对象中, 一份在子类型实例中  

- 事实上, 我们现在可以利用寄生式继承将这两个问题给解决掉  

> 你需要先明确一点: 当我们在子类型的构造函数中调用父类型.call(this, 参数) 这个函数的时候, 就会将父类型中的属性和方法复制一份到 子类型中, 所以父类型本身里面的内容, 我们不在需要
> 这个时候, 我们还需要获取到一份父类型的原型对象中的属性和方法  

- 能不能直接让子类型的原型对象 = 父类型的原型对象呢?  

> 不要这么做, 因为这么做意味着以后修改了子类型原型对象的某个引用类型的时候, 父类型原生对象的引用类型也会被修改 
> 我们使用前面的寄生式思想就可以了

## 原型式继承函数 

- 原型式继承的渊源 

> 这种模式要从道格拉斯*克罗克福德 在 2006 年写的一篇文章说起: Prototypal Inheritance in JavaScript(在JS中使用原型式继承)
> 在这片文章中, 它介绍了一种继承方法, 而且这种继承方法不是通过构造函数来实现的.

- 为了理解这种方法. 我们先再次回顾下JavaScript想实现继承的目的: 重复利用另外一个对象的属性和方法