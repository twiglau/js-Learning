/**
 * eval函数有一个秘密武器: 它不仅仅是一个函数.
 * 大多数函数只能访问定义它们所在的作用域,而不能访问除此之外的作用域.
 * 然而,eval函数具有访问调用它那时的整个作用域的能力.
 * 这是很强大的能力,当编译器编写者首次设法优化JavaScript是,他们发现
 * eval函数很难高效地调用任何一个函数,因为一旦被调用的函数是eval函数,
 * 那么每个函数调用都需要确保在运行时整个作用域对eval函数是可访问的.
 * 
 * 作为一种折中的解决方案,语言标准演化出了辨别两种不同的调用eval函数的方法.
 * 1.一种 "直接" 调用eval函数的方式.
 */
var x = "global";
function test(){
    var x = "local";
    return eval("x"); //direct eval
}
console.log(test());

/**
 * 以上情况下, 编译器需要确保被执行的程序具有完全访问调用者
 * 局部作用域的权限.  其他调用eval函数的方式被认为是 "间接"的.
 * 这些方式在全局作用域内对eval函数的参数求值.
 * 
 * 例如: 绑定eval函数到另一个变量名,通过该变量名调用函数会使代码失去
 * 对所有局部作用域的访问能力.
 */
var x = "global";
function test_01(){
    var x = "local";
    var f = eval;
    return f("x"); // indirect eval
}
console.log(test_01());

/**
 * 直接调用eval函数的确切的定义取决于ECMScript标准相当特殊的规范语言.
 * 在实践中,唯一能够产生直接调用eval函数的语法是可能被(许多的)括号包裹的名称为
 * eval的变量. 编写简介调用eval函数的一种简洁方式是使用表达式序列运算符(,)和
 * 一个明显毫无意义的数字字面量.
 */
(0,eval)(src);
//以上代码如何工作?
//数字字面量0被求值但其值被忽略掉了,括号表示的序列表达式产生
//的结果是eval函数,因此, (0,eval) 的行为几乎与简单的eval函数
//标识符完全一致,一个重要的区别在于整个调用表达式被视为是一种间接
//调用eval函数的方式.

/**
 * 1.将eval函数同一个毫无意义的字面量包裹在序列表式中以达到强制
 *   使用间接调用eval函数的目的.
 * 2.尽可能间接调用eval函数,而不要直接调用eval函数.
 */