/**
 * 题目:
 */
let nAdd;
let t = () => {
    let n = 99;
    nAdd = () => {
        n++;
    };
    let t2 = () => {
        console.log(n);
    };
    return t2;

};
let a1 = t();
let a2 = t();

nAdd();
a1(); //99
a2(); //100

/**
 * 答:
 * 先看下改过后的例子:
 */
var t = function(){
    var n = 99;
    var t2 = function() {
        n++
        console.log(n)
    }
    return t2;
};

var a1 = t();
var a2 = t();

a1(); //100
a1(); //101

a2(); //100
a2(); //101
/**
 * 我们会发现, n 的值都是从 99 开始, 执行一次a1()的时候, 值会加一, 再执行一次,值再加一,但是
 * a1() 和 a2() 并不是公用的. 你可以理解为: 同一个函数形成的多个闭包的值都是相互独立的.
 * 
 * 接下来看这题目,关键在于 nAdd 函数
 * 
 * 
 * 当执行 var a1 = t() 的时候, 变量 nAdd 被赋值为一个函数, 这个函数是 function (){n++},
 * 我们命名这个匿名函数为 fn1 吧.
 * 接着执行 var a2 = t() 的时候,变量 nAdd 又被重写了, 这个函数跟以前的函数长的一模一样,也是
 * function (){n++}, 但是这已经是一个新的函数了, 我们就命名为 fn2.
 * 
 * 所以执行nAdd 函数, 我们执行的是其实是 fn2, 而不是 fn1, 我们更改的是 a2 形成的闭包里的 n 的值,
 * 并没有更改 a1 形成的闭包里的 n 的值, 所以 a1() 的结果为 99, a2()的结果为 100.
 */
