# 模块化

## 什么是模块化?

- 将程序划分成 一个个小的结构;
- 这个结构中编写属于 自己的逻辑代码, 有 自己的作用域, 不会影响到其他的结构;
- 这个结构可以将自己希望暴露的 变量, 函数, 对象 等导出 给其结构使用;
- 也可以通过某种方式,导入另外结构中的 变量, 函数, 对象等;

## 上面提到的 结构, 就是 模块; 按照这种结构划分 开发程序的过程, 就是 模块化开发 的过程

- 无论你多喜欢 JavaScript, 以及它现在发展的有多好, 它都有很多的缺陷

> 比如var定义的变量作用域问题
> 比如JavaScript的面向对象 并不能 像常规面向对象语言一样使用class
> 比如JavaScript没有模块化的问题

- Brendan Eich本人多次承认JavaScript设计之初的缺陷, 但是随着JavaScript的发展以及标准化, 存在的缺陷问题基本都得到了完善
- 无论是 web, 移动端, 小程序端, 服务器端, 桌面应用都被广泛的使用

## 模块化的历史

- 在网页开发的早期, Brendan Eich 开发JavaScript仅仅作为一种 脚本语言, 做一些简单的表单验证 或 动画实现 等, 那个时候代码还是很少的

> 这个时候我们只需要将 JavaScritp 代码写到 `<script>` 标签即可
> 并没有必要放到多个文件中来编写; 甚至当时流行一句话: 通常来说JavaScript程序的长度只有一行

- 但是随着前端和JavaScript的快速发展, JavaScript代码变得越来越复杂

> ajax出现, 前后端开发分离, 意味着后端返回数据后, 我们需要通过 JavaScript进行前端页面的渲染
> SPA的出现, 前端页面变得更加复杂: 包括 前端路由, 状态管理 等等一系列复杂的需求 都需要通过 JavaScript来实现
> 包括Node的实现, JavaScript编写 复杂的后端程序, 没有模块化是致命的

- 所以, 模块化已经是 JavaScript 一个非常迫切的需求

> 但是JavaScript本身, 知道 ES6(ES2015) 才退出了自己的模块化方案
> 在此之前, 为了让JavaScript支持模块化, 涌现出了很多不同的模块化规范: AMD, CMD, CommonJS 等

## 没有模块的带来的问题

- 早期没有模块化带来了很多的问题: 比如命名冲突的问题
- 当然, 我们有办法可以解决上面的问题: 立即函数调用表达式(IIFE)

> IIFE(Immediately Invoked Function Expression)

- 但是, 我们其实带来了新的问题

> 1. 我必须记得 每一个模块返回对象的命名, 才能在其他模块使用过程中正确的使用
> 2. 代码写起来 混乱不堪, 每个文件的代码都需要 包裹在一个匿名函数中来编写
> 3. 在没有合适的规范情况下, 每个人, 每个公司都可能会任意命名, 甚至出现模块名称相同的情况

- 所以, 我们会发现, 虽然实现了模块化, 但是我们的实现过于简单, 并且是没有规范的

> 我们需要制定一定的规范来约束每个人都按照这个规范去编写模块化的代码
> 这个规范中应该包括核心功能: 模块本身可以到处暴露的属性, 模块又可以导入自己需要的属性
> JavaScript社区为了解决上面的问题: 涌现出 一系列好用的规范

## 立即执行函数 新的问题

- 必须记得 给每个模块命令的名称, 才能在其他模块中调用;
- 代码混乱, 每个文件需要用 一个匿名函数中来编写;
- 在 没有合适规范 情况下,可能会任意命名, 甚至出现模块相同的情况;

## 会发现, 虽然实现了模块化, 但是我们的实现过于简单, 并且是没有规范的;

- 需要指定一定的规范来约束每个人都 按照这个规范去编写模块化的代码;
- 这个规范中应该包括核心功能: 模块本身可以导出暴露的属性, 模块又可以导入自己需要的属性;

## CommonJS 和 Node

- CommonJS 是一个规范, 最初提出来是在浏览器以外的地方使用, 并且当时被命名为 ServerJS, 后来为了提现它的广泛性, 修改为 CommonJS,简称 CJS.

  > Node 是 CommonJS 在服务器端一个具有代表性的实现;
  > Browserify 是 CommonJS 在浏览器中的一种实现;
  > webpack 打包工具具备对 CommonJS 的支持和转换;

- 项目: es module -> 支持的模块化代码 -> 模块的源码 [webpack 模块化打包工具]

- Node 中对 CommonJS 进行了支持和实现, 让我们在开发 ndoe 的过程中可以方便的进行模块化开发;

  > 在 Node 中 每个 js 文件都是一个单独的模块;
  > 这个模块中包括 CommonJS 规范的核心变量: exports, module.exports, require;
  > 我们可以使用这些变量来方便的进行模块化开发;

- 模块化的核心是导出和导入, Node 中对其进行了实现:

  > exports 和 module.exports 可以负责 对模块中的内容进行导出;
  > require 函数可以帮助我们 导入其他模块 (自定义模块, 系统模块, 第三方库模块) 中的内容;

- Node 中实现 CommonJS 的本质: 就是对象引用赋值
  > bar 和 exports 是同一个对象
  > 所以, bar 对象是 exports 对象的浅层拷贝;
  > 浅拷贝的本质就是一种引用的赋值而已;

## module.exports

- 在 Node 中我们经常导出东西的时候, 是通过 module.exports 导出的;
  > module.exports 和 exports 有什么关系或者区别?
- 规范中,对 CommonJS 的解析:

  > CommonsJS 中是没有 module.exports 的概念的;
  > 但是为了实现模块的导出, Node 中使用的是 Module 的类, 每一个模块都是 Module 的一个实例, 也就是 module;
  > 所以在 Node 中真正用于导出的其实根本不是 exports, 而是 module.exports;
  > 因为 module 才是导出的真正实现者;

## require 细节

- require 是一个函数, 可以帮助我们引入一个文件(模块)中导入的对象.

- 查找规则:

1. X 是一个核心模块, 如 path, http. => 直接返回
2. X 是以 ./ 或 ../ 或 /(跟目录)开头

- 将 X 当做一个文件在对应的目录下查找;

  > 1. 如果有后缀名, 按照后缀名的格式查找对应的文件
  > 2. 如果没有后缀名,会按照如下顺序: X -> X.js 文件 -> X.json 文件 -> X.node 文件

- 没有找到对应的文件, 将 X 作为一个目录
  > 查找目录下下面的 index 文件: X/index.js -> X/idnex.json -> X/index.node 文件
  > 如果没有找到,那么报错: not found
- 直接是一个 X(没有路径), 并且 X 不是一个核心模块

  > `/Users/lau/Desktop/Node/TestCode/04_learn/02_commonjs/main.js`中编写

  ```js
  require('why')
  ```

  > 会依次从当前目录下->上层目录下->上上层目录下 ... -> 根目录下 `node_modules`中查找 `why`文件夹

  ```js

  paths: [
    '/Users/smallcar/Desktop/项目_进行中/node-learning/02-Modules/02_commonjs/node_modules',
    '/Users/smallcar/Desktop/项目_进行中/node-learning/02-Modules/node_modules',
    '/Users/smallcar/Desktop/项目_进行中/node-learning/node_modules',
    '/Users/smallcar/Desktop/项目_进行中/node_modules',
    '/Users/smallcar/Desktop/node_modules',
    '/Users/smallcar/node_modules',
    '/Users/node_modules',
    '/node_modules'
  ]

  ```

  ## 模块的加载过程

  - 结论一: 模块在被第一次引入时, 模块中的 js 代码会被执行一次;
  - 结论二: 模块被多次引入时, 会缓存, 最终只加载(运行)一次;
    > 为什么只会加载运行一次呢?
    > 这是因为每个模块对象 module 都有一个属性: `loaded`.
    > 为 false 表示还没有加载, 为 true 表示已经加载;
  - 结论三: 如果有循环引入, 加载顺序如何判断?
  - 如果出现如下模块的引用关系, 那么加载顺序是什么呢?
    ```
                ---- main ----
                |            |
                V            V
               aaa       ----bbb
                |        |   |
                V        |   V
               ccc  <----|  eee
                |            ^
                V            |
                ddd ---------
    ```
    > 这个其实是一种数据结构: 图结构;
    > 图结构在遍历的过程中, 有深度优先搜索(DFS, depth first search) 和 广度优先(BFS, breadth first search);
    > Node 采用的是 深度优先算法: main -> aaa -> ccc -> ddd -> eee -> bbb

## CommonJS 规范缺点

- CommonJS 加载模块是同步的;

  > 同步的意味着只有等到对应的模块加载完毕, 当前模块中的内容才能被运行;
  > 这个在服务器不会有什么问题, 因为服务器加载的 js 文件都是本地文件, 加载速度非常快;

- 如果将它应用于浏览器呢?

  > 浏览器加载 js 文件需要先从服务器将文件下载下来, 之后再加载运行;
  > 那么采用同步的就意味着后续的 js 代码都无法正常运行, 即使是一些简单的 DOM 操作;

- 所以在浏览器中,我们通常不使用 CommonJS 规范:

  > 当然在 webpack 中使用 CommonJS 是另外一回事;
  > 因为它会将我们的代码转成浏览器可以直接执行的代码;

- 在早期为了可以在浏览器中使用模块化, 通常会采用 AMD 或 CMD;
  > 但是目前一方面现代的浏览器已经支持 ES Modules, 另一方面借助与 webpack 等工具可以实现对 CommonJS 或者 ES Module 代码的转换;
  > AMD 和 CMD 已经使用非常少了.

# AMD 规范

## AMD 主要是应用于浏览器的一种模块化规范:

- AMD 是 Asynchrouous Module Definition (异步模块定义) 的缩写;
- 它采用的是异步加载模块;
- 事实上 AMD 的规范还要早于 CommonJS, 但是 CommonJS 目前依然在被使用, 而 AMD 使用的较少了;

## 我们提到, 规范只是定义代码应该如何去编写, 只有有了具体的实现才能被应用;

- AMD 实现的比较常用的库是 require.js 和 curl.js;

## require.js 的使用

- 下载 require.js: `https://github.com/requirejs/requirejs`
- 查看例子: `03_AMD`

# CMD 规范

## CMD 规范也是应用于浏览器的一种模块化规范:

- CMD 是 Common Module Definition (通用模块定义) 的缩写;
- 它也采用了异步加载模块, 但是它将 CommonJS 的优点吸收了过来;
- 但是目前 CMD 使用的也非常少了;

## CMD 也有自己比较优秀的实现方案:

- SeaJS

## SeaJS 的使用

- 下载: https://github.com/seajs/seajs
- 使用: `04_CMD` 例子

# ES Module

## JavaScript 没有模块化一直是 它的痛点, 所以才会产生我们前面学习的社区规范: CommonJS, AMD, CMD 等.

## ES Module 和 CommonJS 的模块化有一些不同之处;

- 一方面它使用了 import 和 export 关键字;
- 另一方面它采用编译期的静态分析, 并且也加入了动态引用的方式;

## ES Module 模块采用 export 和 import 关键字来实现模块化;

- export 负责将模块内的内容导出;
- import 负责从其他模块导入内容;

## 采用 ES Module 将自动采用 严格模式: use strict

- 导入方式:

```
// 导出方式有三种

// 1. 方式一:
export const name = "lau";
export const age = 18;
export const sayHello = function(name) {
    console.log("你好, " + name);
}

// 2. 方式二: {} 大括号, 但不是一个对象
// { 放置要导出的变量的引用列表 }
export {
    name,
    age,
    sayHello
}

// 3. 方式三: {} 导出是, 可以给变量起别名
export {
    name as fName,
    age as fAge,
    sayHello as fSayHello
}
```

- 导出方式:

```
// 常见的导入方式 有三种
// 1. 方式一:
import { name, age, sayHello } from './modules/foo.js';
// 2. 方式二: 导出变量之后可以起别名
import { name as iName } from './modules/foo.js';
// 3. 方式三: * as foo
import * as foo from './modules/foo.js';
```

## Export 和 import 结合使用

```
export { sum as barSum } from './bar.js';
```

- 为什么要这样做呢?

  > 在开发和封装一个功能库时, 通常我们希望将暴露的所有接口放到一个文件中;
  > 这样方便指定统一的接口规范, 也方便阅读;
  > 这个时候, 我们就可以使用 export 和 import 结合使用;

  ## default 用法

  - 前面的导出功能都是有名字的导出 (named exports):
    > 在导出 export 时指定了名字;
    > 在导入 import 事需要知道具体的名字;
  - 还有一种导出叫做 默认导出(default export)
    > 默认导出 export 时可以不需要指定名字;
    > 在导入时不需要使用 {}, 并且可以自己来指定名字;
    > 它也方便我们和现有的 CommonJS 等规范相互操作;
  - 注意: 在一个模块中, 只能有一个默认导出 (default export);

  ## import 函数

  - 通过 import 加载一个模块, 是不可以将其放到逻辑代码中的.比如:

  ```
  if(true) {
    import sub from './modules/foo.js'
  }
  ```

  - 为什么出现这个情况?

    > 这是因为 ES Module 在被 JS 引擎解析时, 就必须知道它的依赖关系;
    > 由于这个时候 js 代码没有任何的运行, 所以无法在进行类似于 if 判断中根据代码的执行情况;
    > 甚至下面的这种写法也是错误的: 因为我们必须到运行时才能确定 path 的值;

  - 但是某些情况下, 我们缺缺实实希望动态的来加载某一个模块:
    > 如果根据不同的条件, 动态来选择加载模块的路径;
    > 这个时候我们需要使用 import() 函数来动态加载;

  ```
  let flag = true;
  if(flag) {
    import('./modules/aaa.js').then(aaa => {
      aaa.aaa();
    })
  } else {
    import('./modules/bbb.js').then(bbb => {
      bbb.bbb();
    })
  }
  ```

## ES Module 加载过程

- ES Module 加载 js 文件的过程是编译(解析)时加载的, 并且是异步的:

  > 编译时(解析)时加载, 意味着 import 不能和运行时相关的内容放在一起使用;
  > 比如 from 后面的路径需要动态获取;
  > 比如不能将 import 放到 if 等语句的代码块中;
  > 所以我们有时候也称 ES Module 是静态解析的, 而不是动态或者运行时解析的;

- 异步意味着: JS 引擎在遇到 import 时会去获取这个 js 文件, 但是这个获取的过程是异步的, 并不会阻塞主线程继续执行;

  > 也就是说设置了 type = module 的代码, 相当于在 script 标签上也加上了 async 属性;
  > 如果我们后面有普通的 script 标签以及对应的代码, 那么 ES Module 对应的 js 文件和代码不会阻塞它们的执行;

- ES Module 通过 export 导出的是变量本身的引用;

  > export 在导出一个变量时, js 引擎会解析这个语法, 并且创建 `模块环境记录`( module environment record);
  > 模块环境记录 会和变量进行 绑定(binding), 并且这个绑定是实时的;
  >
  > > bingings: 实时绑定;

  ```
  const name = name;
  const age = age;
  ```

  > 而在导入的地方, 我们是可以实时的获取到绑定的最新值的;

- 所以, 如果在导出的模块中修改了变化, 那么导入的地方可以实时获取最新的变量;
- 注意: 在导入的地方不可以修改变量, 因为它只是被绑定到了这个变量上(其实是一个常量)

```
> Uncaught TypeError: Assignment to constant variable. at main.js: 54
```

- 思考: 如果 bar.js 中导出的是一个对象, 那么 main.js 中是否可以修改对象中的属性呢?
  > 答案是可以的, 因为它们指向同一块内存空间;

## 在 Node 中使用 ES Module

- 要么需要命令文件为 `.mjs`的扩展名
- 要么需要在 `package.json`中的 `type`:设置为 `module` 类型.
- 需要: To load an ES module, set "type": "module" in the package.json or use the .mjs extension.

## CommonJS 和 ES Module 交互

- 结论一: 通常情况下, CommonJS 不能加载 ES Module

  > 因为 CommonJS 是同步加载的, 但是 ES Module 必须经过静态分析等, 无法在这个时候执行 JavaScript 代码;
  > 但是这个并非绝对的, 某些平台在实现的时候可以对代码进行针对性的解析, 也可能会支持;
  > Node 当中是不支持的;

- 结论二: 多数情况下, ES Module 可以加载 CommonJS
  > ES Module 在加载 CommonJS 时, 会将其 module.exports 导出的内容作为 default 导出方式来使用;
  > 这个依然需要看具体的实现, 比如 webpack 中是支持的, Node 最新的 Current 版本也是支持的;
  > 但是在最新的 LTS 版本中就不支持;
