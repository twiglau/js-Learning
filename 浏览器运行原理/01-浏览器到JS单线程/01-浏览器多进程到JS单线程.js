/**
 * 大纲
 * > 区分进程和线程
 * > 浏览器是多进程的
 * > 浏览器都包含哪些进程?
 * > 浏览器多进程的优势
 * > 重点是浏览器内核(渲染进程)
 * > Browser进程和浏览器内核(Render进程)的通信过程
 * > 梳理浏览器内核中线程之间的关系
 * > GUI渲染线程与JS引擎线程的关系
 * > JS阻塞页面加载
 * > WebWorker,JS的多线程?
 * > WebWorker与SharedWorker
 * > 简单梳理下浏览器渲染流程
 * > load事件与DOMContentLoader事件的先后
 * > css加载是否阻塞dom树渲染?
 * > 普通图层和复合图层
 * > 从Event Loop谈JS的运行机制
 * > 事件循环机制进一步补充
 * > 单独说说定时器
 * > setTimeout而不是setInterval
 * > 事件循环进阶: macrotask 与 microtask
 * > 最后
 */

/**
 * 1. 区分进程和线程
 * 线程和进程区分不清,是很多新手都会犯的错误.
 * > 进程是一个工厂,工厂有它的独立资源-工厂之间相互独立-线程是工厂中的工人,多个工人协作完成任务-工厂内有一个或多个
 *   工人-工人之间共享空间
 * 完善概念:
 * > 工厂的资源->资源分配的内存(独立的一块内存)-工厂之间的相互独立->进程之间相互独立-多个工人协作完成任务->对个线程在进程中协作完成任务
 *   -工厂内有一个或多个工人->一个进程由一个或多个线程组成-工人之间共享空间->同一进程下的各个线程之间共享程序的内存空间(包括代码段,数据集,堆等)
 * 再巩固下:
 * 如果是windows电脑中,可以打开任务管理器,可以看到有一个后台进程列表. 对,那里就是查看进程的地方,而且可以看到每个进程的内存资源信息以及cpu占有率.
 * 
 * 如图 01.1 
 * 所以,应该更容易理解:
 * 进程是cpu资源分配的最小单位(系统会给它分配内存)
 * 
 * 最后,再用较为官方的属于描述:
 * > 进程是cpu资源分配的最小单位(是能拥有资源和独立运行的最小单位)
 * > 线程是cpu调度的最小单位(线程是建立在进程的基础上的一次程序运行单位,一个进程中可以有多个线程)
 * 
 * 提示:
 * > 不同进程之间也可以通信,不过代价较大
 * > 现在,一般通用的叫法: 单线程与多线程,都是指在一个进程内的单和多. (所以核心还是得属于一个进程才行)
 */

/**
 * 2. 浏览器是多进程的
 * 理解了进程与线程了区别后,接下来对浏览器进行一定程度上的认识:
 * > 浏览器是多进程的
 * > 浏览器之所以能够运行,是因为系统给它的进程分配了资源(cpu,内存)
 * > 简单点理解,每打开一个tab页,就相当于创建了一个独立的浏览器进程.
 * 
 * 关于以上几点验证,如下:
 * 如图 01.2
 * 
 * 图中打开了Chrome浏览器的多个标签页,然后可以在Chrome的任务管理器中看到多个进程(分别是每一个Tab页面有一个独立的进程,以及一个主进程).
 * 注意:
 * 在这里浏览器应该也有自己的优化机制,有时候打开多个tab页后,可以在Chrome任务管理器中看到,有些进程被合并了(所以每一个Tab标签
 * 对应一个进程并不一定是绝对的)
 */

/**
 * 3. 浏览器都包含哪些进程?
 * 知道了浏览器是多进程后,再来看看它到底包含哪些进程: (为了简化理解,仅列举主要进程)
 * 
 * > Browser进程: 浏览器的主进程(负责协调,主控),只有一个. 作用有;
 *   - 负责浏览器界面显示,与用户交互,如前进,后退等
 *   - 负责各个页面的管理,创建和销毁其他进程
 *   - 将Renderer进程得到的内存中的Bitmap,绘制到用户界面上
 *   - 网络资源的管理,下载等
 * > 第三方插件进程: 每种类型的插件对应一个进程,仅当使用该插件时才创建
 * > GPU进程: 最多一个,用于3D绘制等
 * 
 * 浏览器渲染进程(浏览器内核)(Renderer进程,内部是多线程的):默认每个Tab页面一个进程,互补影响.主要作用为
 * - 页面渲染,脚本执行,事件处理等
 * 强化记忆:
 * 在浏览器中打开一个网页相当于新起了一个进程(进程内有自己的多线程)
 * 
 * 当然,浏览器有时会将多个进程合并(譬如打开多个空白标签页后,会发现多个空白便签页被合并成了一个进程),如图
 * 
 * 如图 01.3
 * 另外,可以通过Chrome的更多工具 -> 任务管理器自行验证
 */

/**
 * 4. 浏览器多进程的优势
 * 相比于单进程浏览器,多进程有如下优点:
 * > 避免单个page crash 影响整个浏览器
 * > 避免第三方插件crash影响整个浏览器
 * > 多进程充分利用多核优势
 * > 方便使用沙盒模型隔离插件等进程,提高浏览器稳定性
 * 
 * 简单理解:
 * 如果浏览器是单进程,那么某个Tab页崩溃了,就影响了整个浏览器,体验有多差;同理如果是单进程,插件崩溃了也会影响整个
 * 浏览器; 而且多进程还有其他的诸多优势..
 * 
 * 当然,内存等资源消耗也会更大,有点空间换时间的意思.
 */

/**
 * 5. 重点是浏览器内核(渲染进程)
 * 重点来了,我们可以看到,上面提到了这么多的进程,那么,对于普通的前端操作来说,最终要的是什么呢?
 * 答案是渲染进程
 * 
 * 可以这样理解,页面的渲染,JS的执行,事件的循环,都在这个进程内进行. 接下来重点分析这个进程
 * 
 * 请牢记,浏览器的渲染进程是多线程的(这点如果不理解,请回头看进程和线程的区分)
 * 
 * 终于到了线程这个概念了,那么接下来看看它都包含哪些线程(列举一些主要常驻线程):
 * 
 * GUI渲染进程
 * > 负责渲染浏览器页面,解析HTML,CSS,构建DOM树和RenderObject树,布局和绘制等.
 * > 当界面需要重绘(Repaint)或由于某种操作引发回流(reflow)时,该线程就会执行.
 * > 注意,GUI渲染线程与JS引擎线程是互斥的,当JS引擎执行时GUI线程会被挂起(相当于被冻结了),
 *   GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行.
 * 
 * JS引擎线程
 * > 也称为JS内核,负责处理JavaScript脚本程序.(例如V8引擎)
 * > JS引擎线程负责解析JavaScript脚本,运行代码.
 * > JS引擎一直等待这任务队列中任务的到来,然后加以处理,一个Tab页(renderer进程)中无论什么时候都
 *   只有一个JS线程在运行JS程序
 * > 同样注意,GUI渲染线程与JS引擎线程是互斥的,所以如果JS执行的时间过长,这样就会造成页面的渲染不连贯,
 *   导致页面渲染加载阻塞.
 * 
 * 事件触发线程
 * > 归属于浏览器而不是JS引擎,用来控制事件循环(可以理解,JS引擎自己都忙不过里啊,需要浏览器另开线程协助)
 * > 当JS引擎执行代码块如setTimeOut时(也可来自浏览器内核的其他线程,如鼠标点击,AJAX异步请求等),会将
 *   对应任务添加到事件线程中
 * > 当对应的事件符合触发条件被触发时,该线程会把事件添加到待处理队列的队尾,等待JS引擎的处理
 * > 注意,由于JS的单线程关系,所以这些待处理队列中的事件都得排队等待JS引擎处理(当JS引擎空闲时才会去执行)
 * 
 * 定时触发器线程
 * > 传说的setInterval与setTimeout所在线程
 * > 浏览器定时计数器并不是由JavaScript引擎计数的,(因为JavaScript引擎是单线程的,如果处于阻塞线程状态就会影响
 *   计数器的准确)
 * > 因此通过单独线程来计数并触发定时(计时完毕后,添加到事件队列中,等待JS引擎空闲后执行)
 * > 注意,W3C在HTML标准中规定,规定要求setTimeout中低于4ms的时间间隔算为4ms.
 * 
 * 异步http请求线程
 * > 在XMLHttpRequest在连接后是通过浏览器新开一个线程请求
 * > 将检测到状态变更时,如果设置有回调函数,异步线程就产生状态变更事件,将这个回调再放入事件队列中,再由JavaScript引擎执行.
 * 
 * 看到这里,如果觉得累了,可以先休息下,这些概念需要被消化,毕竟后续将提到的事件循环机制就是基于事件触发线程的,所以如果仅仅是
 * 看某个碎片化知识,可能会有一种似懂非懂的感觉. 要完成的梳理一遍才能快速沉淀,不易遗忘.
 * 
 * 如图 01.4 
 * 
 * 再说一点,为什么JS引擎是单线程的? 多线程的复杂性.
 */

/**
 * 6. Browser进程和浏览器内核(Renderer进程)的通信过程
 * 看到这里,首先,应该对浏览器内的进程和线程都有一定理解了,那么接下来,再谈谈浏览器的Browser进程(控制进程)是如何和内核通信的.
 * 这点也理解后,就可以将这部分的知识串联起来,从头到尾有一个完整的概念.
 * 
 * 如果自己打开任务管理器,然后打开一个浏览器,就可以看到: 任务管理器中出现了两个进程(一个主控进程,一个则是打开Tab页的渲染进程).
 * 然后在这前提下,看下整个的过程:(简化了很多)
 * > Browser进程收到用户请求,首先需要获取页面内容(譬如通过网络资源),随后将该任务通过RendererHost接口传递给Render进程
 * > Renderer进程的Renderer接口收到消息,简单解释后,交给渲染线程,然后开始渲染
 * > 渲染进程接收请求,加载网页并渲染网页,这其中可能需要Browser进程获取资源和需要GPU进程来帮助渲染
 * > 当然可能会有JS线程操作DOM(这样可能会造成回流并重绘)
 * > 最后Render进程将结果传递给Browser进程
 * > Browser进程接收到结果并将结果绘制出来
 * 
 * 这里绘制张简单的图:(很简化)
 * 
 * 如图 01.5
 * 
 * 看完这一整套流程,应该对浏览器的运作有了一定理解了,这样有了知识架构的基础后,后续就方便往上填充内容.
 * 这块再往深处讲的话就涉及到浏览器内核源码解析了,不属于本文范围.
 * 如果这一块要深挖,建议去读写浏览器内核源码解析文章,或者可以先看看参考来源中的第一篇文章.
 * https://www.cnblogs.com/lhb25/p/how-browsers-work.html
 */

/**
 * 7. 梳理浏览器内核中线程之间的关系
 * 到了这里,已经对浏览器的运行有了一个整体的概念,接下来,先简单梳理一些概念
 * 
 * 7.1 GUI渲染线程与JS引擎线程互斥
 * 由于JavaScript是可操纵DOM的,如果在修改这些元素同时渲染界面(即JS线程和UI线程同时运行),那么渲染线程
 * 前后获得的元素数据就可能不一致了.
 * 
 * 因此为了防止渲染出现不可预期的结果,浏览器设置GUI渲染线程与JS引擎为互斥的关系,当JS引擎执行时GUI线层会被挂起.
 * GUI更新则会保存在一个队列中等到JS引擎线程空闲时立即被执行.
 * 
 * 7.2 JS阻塞页面加载
 * 从上述的互斥关系,可以推导出,JS如果执行时间过长就会阻塞页面.
 * 譬如,假设JS引擎正在进行巨量的计算,此时就算GUI有更新,也会被保存到队列中,等待JS引擎空闲后执行. 然后,由于巨量计算,
 * 所以JS引擎很可能很久很久后才能空闲,自然会感觉到巨卡无比.
 * 
 * 所以,要尽量避免JS执行时间过长,这样就会造成页面的渲染不连贯,导致页面渲染加载阻塞的感觉.
 * 
 * 7.3 WebWorker,JS的多线程?
 * 前文中有提到JS引擎是单线程的,而且JS执行时间过长会阻塞页面,那么JS就真的对cpu密集型计算无能为力么?
 * 所以,后来HTML中支持了Web Worker.
 * MDN的官方解释是:
 * > WebWorker为Web内容在后台线程中运行脚本提供了一种简单的方法。
 * > 线程可以执行任务而不干扰用户界面
 * > 一个worker是使用一个构造函数创建的一个对象(e.g.Worker())运行一个命名的JavaScript文件
 * > 这个文件包含将在工作线程中运行的代码;
 * > workers运行在另一个全局上下文中,不同于当前的window
 * > 因此，使用window快捷方式获取当前全局的范围(而不是self)在一个Worker内将返回错误
 * 
 * 这样理解:
 * > 创建Worker时,JS引擎向浏览器申请一个子线程(子线程是浏览器开的,完全受主线程控制,而且不能操作DOM)
 * > JS引擎线程与worker线程间通过特定的方式通信(postMessage API,需要通过序列对象来与线程加护特定的数据)
 * 
 * 所以,如果有非常耗时的工作,请单独开一个Worker线程,这样里面不管如何翻天覆地都不会影响JS引擎主线程,只待计算
 * 出结果后,将结果通信给主线程即可.
 * 而且注意下,JS引擎是单线程的,这一点的本质仍然为改变,Worker可以理解是浏览器给JS引擎开的外挂,专门用来解决那些大量
 * 计算问题.
 * 其他,关于Worker的详解就不是本文的范畴了.
 * 
 * 7.4 WebWorker 与 SharedWorker
 * > WebWorker只属于某个页面,不会和其他页面的Render进程(浏览器内核进程)共享
 * > 所以Chrome在Render进程中(每一个Tab页就是一个render进程)创建一个新的线程来运行Worker中的JavaScript程序.
 * > SharedWorker是浏览器所有页面共享的,不能采用与Worker同样的方式实现,因此它不隶属于某个Render进程,可以为多个
 *   Render进程共享使用
 * > 所以Chrome浏览器为SharedWorker单独创建一个进程来运行JavaScript程序,在浏览器中每个相同的JavaScript只存在
 *   一个SharedWorker进程,不管它被创建多少次.
 * 
 * 看到这里,应该就很容易明白了,本质上就是进程和线程的区别. SharedWorker由独立的进程管理,WebWorker只是属于render
 * 进程下的一个线程
 */

/**
 * 8. 简单梳理下浏览器渲染流程
 * 
 */