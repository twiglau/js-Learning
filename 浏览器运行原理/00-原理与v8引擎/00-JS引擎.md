# 浏览器

## 为什么需要JavaScript引擎？

- 高级的编程语言都是需要转成 最终的机器指令来执行的；
- 事实上我们编写的JavaScript无论你交给浏览器或者Node执行，最后都是需要被 CPU 执行的；
- 但是CPU只认识自己的指令集，实际上是机器语言， 才能被 CPU 所执行；
- 所以我们需要JavaScript引擎帮助我们将JavaScript代码翻译成CPU指令来执行；

## 浏览器内核和JS引擎的关系

- 以WebKit为例，WebKit事实上由两部分组成的：

> WebCore: 负责HTMl解析， 布局， 渲染等相关的工作；
> JavaScriptCore: 解析，执行JavaScript代码；

## V8引擎的原理

- V8引擎的定义：

> V8 是用C++编写的Google开源高性能JavaScript和WebAssembly引擎， 它用于Chrome和Node.js等。
> 它实现 ECMAScript和WebAssembly,并在Windows 7 或更高版本, macOS 10.12+和使用x64, IA-32, ARM或MIPS处理器的Linux系统上运行.
> V8可以独立运行, 也可以嵌入到任何C++应用程序中.

```

JavaScript源代码 -> [ Parse ] -> AST抽象语法树 -> [ Ignition ] -> bytecode  -> 运行结果
                                                     |           /  ^
                            收集信息,比如类型信息      |          /   | Deoptimization
                                                     V         V    |
                                                [ TurboFan ] ---> MachineCode -> 运行结果
                                                                  优化的机器码
                                                 
```

> 语法分析, 词法分析
> AST树: www.astexplorer.net

- V8引擎的架构

1 V8引擎本身的源码非常复杂, 大概有超过 100w行 C++代码, 通过了解它的架构, 我们可以知道他是如何对JavaScript执行的:
> Parse 模块会将 JavaScript 代码转换成AST (抽象语法树), 这是因为解释器并不直接认识JavaScript代码;
> 如果函数没有被调用, 那么是不会被转换成AST的;
> Parse的V8文档: https://v8.dev/blog/scanner

2 Ignition是一个解释器,  会将AST转换成ByteCode (字节码)
> 同时会收集TurboFan优化所需要的信息 (比如函数参数的类型信息, 有了类型才能进行真实的运算);
> 如果函数只调用一次, Ignition会执行解释执行 ByteCode;
> Ignition的V8官方文档: https://v8.dev/blog/ignition-interpreter

3 TurboFan 是一个编译器, 可以将字节码编译为CPU可以直接执行的机器码:
> 如果一个函数被多次调用, 那么 就会被标记为 热点函数, 那么就会经过 TurboFan 转换成优化的机器码, 提高代码的执行性能;
> 但是, 机器码实际上也会被还原为 ByteCode, 这是因为如果后续执行函数的过程中, 类型发生了变化 (比如sum函数原来执行的是 number 类型, 后来执行变成了 string 类型), 之前优化的机器码并不能正确的处理运算, 就会逆向的转换成字节码;
> TurboFan的V8官方文档: https://v8.dev/blog/turbofan-jit

- V8引擎的解析图

```
                                            PreParser
                                    /            |
     |                           tokens           |
     |                              /             V
     |                             /
     |  内核html->js      js代码   /
Blink|  ----->  Stream  ------> Scanner --------> Parser --------> Ignation
     |  ASCII            UTF-16           tokens           AST        |
     |  Latin             code                                        | bytecode
     |  UTF-8             units                                       V
     |  Chunks                                                      识别
```  

那么我们的JavaScript源码是如何被解析(Parse过程)的呢?
1 Blink将源码交给V8引擎, Stream 获取到源码并且进行编码转换;
2 Scanner会进行词法分析(lexical analysis), 词法分析会将代码转换成tokens
3 加下来tokens会被转换成AST树, 经过Parser和PerParser:
> Parser 就是直接将tokens转成AST树架构;
> PreParser 称之为预解析, 为什么需要预解析呢?
>
>> 这是因为并不是所有的JavaScript代码, 在一开始时就会被执行. 那么对所有的JavaScript代码进行解析, 必然会影响网页的运行效率;
>> 所以V8引擎就实现了 Lazy Parsing (延迟解析) 的方案, 它的作用是 将不必要的函数进行预解析, 也就是只解析暂时需要的内容, 而对
>> 函数的全量解析 是在 函数被调用时 才会进行.
>> 比如我们在一个函数 outer 内部定义了另外一个函数 inner, 那么 inner 函数就会进行预解析.  
> 生成AST树后, 会被Ignition转成字节码(bytecode), 之后的过程就是代码的执行过程 

