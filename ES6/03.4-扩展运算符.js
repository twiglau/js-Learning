/**
 * 与剩余参数关联最密切的就是扩展运算符. 剩余参数允许你把多个独立的参数合并到一个数组中;
 * 而扩展运算符则允许将一个数组分割,并将各个项作为分离的参数传给函数. 考虑下 Math.max()
 * 方法,它接受任意数量的参数,并会返回其中的最大值. 这里有个此方法的简单用例:
 */
let value1 = 25,value2 = 50;
console.log(Math.max(value1,value2)); //50
/**
 * 若像本例这样仅处理两个值,那么 Math.max() 非常容易使用:将这两个值传入,就会返回较大的那个.
 * 但若想处理数组中的值,此时该如何找到最大值? Math.max() 方法并不允许你传入一个数组,因此在
 * ES5 或更早版本中,你必须自行搜索整个数组,或像下面这样使用 apply() 方法:
 */
let values = [25,50,75,100]
console.log(Math.max.apply(Math,values)); //100
/**
 * 该解决方案是可行的,但如此使用 apply() 会让人有一点疑惑,它实际上使用了额外的语法混淆了代码的
 * 真实意图.
 * 
 * ES6的扩展运算符令这种情况变得简单.无须调用 apply(),你可以像使用剩余参数那样在该数组前添加...,
 * 并直接将其传递给 Math.max(). JS引擎将会将该数组分割为独立参数并把它们传递进去,就像这样:
 */
let values_01 = [25,50,75,100]
//等价于 console.log(Math.max(25,50,75,100));
console.log(Math.max(...values_01)); //100

/**
 * 现在调用 Math.max() 看起来更传统一些,并避免了为一个简单数学操作使用复杂的 this 绑定
 * (即在上个例子中提供给 Math.max.apply() 的第一个参数 ).
 * 
 * 你可以将扩展运算符与其他参数混用. 假设你想让 Math.max() 返回的最小值为0 (以防数组中
 * 混入了负值),你可以将参数 0 单独传入,并继续为其他参数使用扩展运算符,如下:
 */
let values_02 = [-25,-50,-75,-100]
console.log(Math.max(...values_02,0));
/**
 * 本例中传给 Math.max() 的最后一个参数是 0, 它跟在使用扩展运算符的其他参数之后传入.
 * 用扩展运算符传递参数,使得更容易将数组作为函数参数来使用,你会发现在大部分场景中扩展运算符都是
 * apply() 方法的合适替代品.
 * 
 * 除了你至今看到的默认参数与剩余参数的用法之外,在ES6中还可以在 JS 的 Function 构造器中使用
 * 这两类参数.
 */