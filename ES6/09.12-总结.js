/**
 * 1.ES6的类起初是作为ES5传统继承模型的语法糖,但添加了许多特性来减少错误.
 * 
 * 2.ES6的类配合原型继承来工作,在类的原型上定义了非静态的方法,而静态的方法最终
 * 则被绑定在类构造器自身上.类的所有方法初始都是不可枚举的,这更契合了内置对象的
 * 行为,后者的方法默认情况下通常都不可枚举.此外,类构造器被调用时不能缺少 new,
 * 确保了不能意外地将作为函数来调用.
 * 
 * 3.基于类的继承允许你从另一个类,函数或表达式上派生新的类.这种能力意味着你可以调用
 * 一个函数来判断需要继承的正确基类,也允许你使用混入或其他不同的组合模式来创建一个
 * 新类.新的继承方式让继承内置对象(例如数组)也变为可能,并且其工作符合预期.
 * 
 * 4.你可以在类构造器内部使用 new.target,以便根据类如何被调用来做出不同的行为.最常
 * 用的就是创建一个抽象基类,直接实例化它会抛出错误,但它仍然允许被其他类所继承.
 */