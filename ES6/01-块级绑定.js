/**
 * 变量声明的工作方式历来是 JS 编程中最微妙的部分之一.在大多数类C语言中,变量(或绑定)
 * 总是在它被声明的地方创建.然而JS就不是这样,变量实际创建的位置取决于你如何声明它,而
 * ES6提供了额外选择以便你能更轻易地控制变量的作用域.
 * 本章会演示传统的 var 声明为何会令人困惑,并介绍ES6的块级绑定,然后再给出相关的一些
 * 最佳实践.
 * 
 * 1.var声明与变量提升
 * 2.块级声明
 *   2.1 let声明
 *   2.2 禁止重复声明
 *   2.3 常量声明
 *       2.3.1 对比常量声明与let声明
 *       2.3.2 使用const声明对象
 *   2.4 暂时性死区
 * 3.循环中的块级绑定
 *   3.1 循环内的函数
 *   3.2 循环内的let声明
 *   3.3 循环内的常量声明
 * 4.全局块级绑定
 * 5.块级绑定新的最佳实践
 * 6.总结
 * 
 */

/**
 * 1.var声明与变量提升
 * 使用var 关键字声明的变量,无论其实际声明位置在何处,都会被视为声明与所在函数的项部
 * (如果声明不在任意函数内,则视为在全局作用域的顶部). 这就是所谓的变量提升(hoisting).
 * 参考如下函数:
 */
function getValue_00(condition){
    if(condition){
        var value = "blue";
        //其他代码
        return value;
    } else {
        //value 在此处可访问,值为 undefined
        return value;
    }

    //value 在此处可访问,值为 undefined
}
console.log(
    getValue_00(false),
    getValue_00(true)
)
//如果你不太熟悉JS,或许会认为仅当condition的值为true时,变量 value 才会被创建.但实际上,
//value 无论如何都会被创建. JS引擎在后台对 getValue 函数进行了调整,就像下面:
function getValue_01(condition){
    var value;
    if(condition){
        value = "blue";

        //其他代码

        return value;
    } else {
        return null;
    }
}
//value 变量的声明被提升到了顶部,而初始化工作则保留在原处,这意味着在 else 分支内 value
//变量也是可访问的,此处它的值会是 undefined, 因为它并没有被初始化.

/**
 * JS的初学者经常需要花点时间才能习惯变量提升,而如果不理解这种特有行为,就可能导致bug.正因为
 * 如此, ES6引入了块级作用域,让变量的声明周期更加可控.
 */

/**
 * 2.块级声明
 * 块级声明也就是让所声明的变量在指定块的作用域外无法被访问. 块级作用域(又被称为词法作用域)
 * 在如下情况被创建:
 * ---> 在一个函数内部
 * ---> 在一个代码块(由一对花括号包裹)内部
 * 
 * 块级作用域是很多类C语言的工作机制,ES6引入块级声明,是为了给JS添加灵活性以及与其他
 * 语言的一致性.
 */

/**
 * 2.1 let声明
 * let 声明的语法与var的语法一致. 你基本上可以用 let 来代替 var 进行变量声明,但会将变量的作用域限制
 * 在当前代码块中(其他细微差别会在稍后讨论). 由于 let 声明并不会被提升到当前代码块的顶部,因此你需要手动
 * 将 let 声明放置到顶部,以便让变量在整个代码块内部可用. 这里有个范例:
 */
function getValue_03(condition){
    if(condition){
        let value = "blue";
        //其他代码
        return value;
    } else {
        //value 在此处不可用
        return null;
    }
    // value 在此处不可用
}
/**
 * 如你所愿,这种写法的 getValue 函数的行为更接近其他类C语言. 由于变量 value 声明使用的是 let 而非 var,
 * 该声明就没有被提升到函数定义的顶部,因此变量 value 在 if 代码块外部是无法访问的;并且在 condition 的值为
 * false时,该变量是永远不会被声明并初始化的.
 */

/**
 * 2.2 禁止重复声明
 * 如果一个标识符已经在代码块内部被定义,那么在此代码块内使用同一个标识符进行 let 声明就会导致抛出错误.例如:
 */


var count = 30;
//语法错误
let count = 40;


/**
 * 在本例中,count变量被声明了两次: 一次使用 var, 另一次使用 let. 因为 let 不能在同一作用域内重复声明
 * 一个已有标识符,此处的 let 声明就会抛出错误. 另一方面,在嵌套的作用域内使用 let 声明一个同名的新变量,
 * 则不会抛出错误,以下代码对此进行了演示:
 */


var count = 30;
// 不会抛出错误
if(condition){
    let count = 40;
    //其他代码
}

/**
 * 此处的 let 声明并没有抛出错误,这是因为它在 if 语句内部创建了一个新的 count 变量,
 * 而不是在同一级别再次创建此变量. 在 if 代码块内部,这个新变量会屏蔽全局的 count 变量,
 * 从而在局部阻止对于后者的访问.
 */

/**
 * 2.3 常量声明
 * 在ES6中里也可以使用 const 语法进行声明. 使用 const 声明的变量会被认为是常量(constant),
 * 意味着它们的值在被设置完成后就不能再被改变,正因为如此,所有的 const 变量都需要在声明时进行
 * 初始化,实例如下:
 */

//有效的常量
const maxItems = 30;
//语法错误:未进行初始化
const name;

/**
 * maxItems 变量被初始化了,因此它的 const 声明能正常起效,而 name 变量没有被初始化,
 * 导致在试图运行这段代码时抛出了错误.
 * 
 * 对比常量声明与let声明
 * 常量声明与let声明一样,都是块级声明.这意味着常量在声明它们的语句块外部是无法访问的,并且
 * 声明也不会被提升,实例如下:
 */


if(condition){
    const maxItems = 5;
    //其他代码
}
// maxItems 在此处无法访问

/**
 * 此代码中,常量 maxItems 在 if 语句内被声明. maxItems 在代码块外部无法被访问,因为该语句
 * 已结束执行.
 * 
 * 与 let 的另一个相似之处,是 const 声明会在同一作用域(全局或是函数作用域)内定义一个已有变量时会
 * 抛出错误,无论是该变量此前是用 var 声明的, 还是用 let 声明的. 例如以下代码:
 */

var message = "Hello!";
let age = 25;
//二者均会抛出错误
const message = "Goodbye!";
const age = 30;

//两个 const 声明都可以单独使用,但在前面添加了 var 与 let 声明的情况下,二者都会
//出问题.
//尽管有上述相似之处,但 let 与 const 之间仍然有个必须牢记的重大区别: 试图对之前用
//const 声明的常量进行赋值会抛出错误,无论是在严格模式还是非严格模式下:


const maxItems = 5;
maxItems = 6; //抛出错误

//与其语言的常量类似,maxItems变量不能被再次赋值,
//然而与其他语言不通,JS的常量如果是一个对象,它所包含的值是可以被修改的.

/**
 * 使用 const 声明对象
 * const 声明会阻止对于变量绑定与变量自身值的修改,这意味着 const 声明并不会阻止对变量成员的修改.例如:
 */
const person = {
    name: "Nicholas"
};
//工作正常
person.name = "Greg";

//抛出错误
person = {
    name:"Greg"
};

console.log({person})
/**
 * 此处 person 在初始化时被绑定了带有一个属性的对象. 修改 person.name 是可能的,并不会抛出错误,
 * 因为该操作只修改了 person 对象的成员,而没有修改 person 的绑定值. 当代码试图为 person 对象
 * 自身赋值时 (这会改变变量绑定),就会导致错误. const 在变量上的微妙工作机制容易导致误解,但只需记住:
 * const 阻止的是对于变量绑定的修改,而不是阻止对成员值的修改.
 */

/**
 * 2.4暂时性死区
 * 使用 let 或 const 声明的变量,在达到声明处之前都是无法访问的,视图访问会导致一个引用错误,即使在通常
 * 是安全的操作时(例如使用 typeof 运算符),也是如此.实例如下:
 */
if(condition){
    console.log(typeof value); //引用错误
    let value = "blue";
}
/**
 * 此处的 value 变量使用了 let 进行定义与初始化,但该语句永远不会被执行,因为声明之前的那行代码抛出了一个错误.
 * 出现该问题是因为:
 * value 位于被 JS社区称为 暂时性死区(temporal dead zone, TDZ)的区域内. 该名称并未在ECMAScript规范中
 * 被明确命名,但经常被用于描述 let 或 const 声明的变量为何在声明处之前无法被访问.本小节的内容涵盖了暂时性死
 * 区所导致的声明位置的微妙之处,尽管这里使用的都是 let,但替换为 const 也会有相同情况.
 * 
 * 当JS引擎监视接下来的代码块并发现变量声明时,它会在面对 var 的情况下将声明提升到函数或全局作用域的顶部,而面对
 * let 或 const 时会将声明放在暂时性死区内. 任何在暂时性死区内访问变量的企图都会导致 "运行时"错误(runtime error).
 * 只有执行到变量的声明语句时,该变量才会从暂时性死区内被移除并可以安全使用.
 * 
 * 使用 let 或 const 声明的变量,若视图在定义位置之前使用它,无论如何都不能避免暂时性死区.而且正如如何都不能避免暂时
 * 性死区.而且正如上例演示的,这甚至影响了通常安全的 typeof 运算符. 然而,你可以在变量被定义的代码块之外对该变量使用
 * typeof, 尽管其结果可能并非预期. 考虑以下代码:
 */
console.log(typeof value); // "undefined"
if(condition){
    let value = "blue";
}
/**
 * 当 typeof 运算符被使用时, value 并没有在暂时性死区内,因为这发生在定义 value 变量的代码块外部.这意味着此时并
 * 没有绑定 value 变量,而 typeof 仅单纯返回了 "undefined".
 * 暂时性死区只是块级绑定的一个独特表现,而另一个独特表现则是在循环时使用它.
 */

/**
 * 3.循环中的块级绑定
 * 开发者最需要使用变量的块级作用域的场景,或许就是在 for 循环内,也就是想让一次性的循环计数器仅能在循环内部使用.
 * 例如,以下代码在 JS 中并不罕见:
 */
for(var i = 0; i < 10; i++){
    process(items[i]);
}
//i 在此处仍然可被访问
console.log(i);
/**
 * 在其他默认使用块级作用域的语言中,这个例子能够预期工作,也就是只有 for 才能访问变量 i. 然而在JS中,循环结束后 i
 * 仍然可被访问,因为 var 声明导致了变量提升. 若像如下代码那样换为使用let,则会看到预期行为:
 */
for(let i = 0; i < 10; i++){
    process(items[i]);
}
//i 在此处不可访问,抛出错误
console.log(i);
//本例中的变量 i 仅在 for 循环内部可用,一旦循环结束,该变量在任意位置都不可访问.

/**
 * 3.1循环内的函数
 * 长期以来,var 的特点使得循环变量在循环作用域之外仍然可被访问,于是在循环内创建函数就变得很有问题.考虑如下代码:
 */
var funcs = [];
for(var i = 0; i < 10; i++){
    funcs.push(function() { console.log(i); });
}
funcs.forEach(function(func){
    func();
})
/**
 * 原本可能预期这段代码会输出 0到9 的数值,但它却在同一行将数值 10输出了十次.这是因为变量 i 在循环的每次迭代中都被
 * 共享了,意味着循环内创建的那些函数都拥有对于同一变量的引用.在循环结束后,变量 i 的值会是 10,因此当console.log(i)
 * 被调用是,每次都打印出 10.
 * 
 * 为了修正这个问题,开发者在循环内使用立即调用函数表达式(IIFEs),以便在每次迭代中强制创建变量的一个新副本,示例如下:
 */
var funcs = [];
for(var i = 0; i < 10; i++){
    funcs.push(
        (function(value){
            return function(){
                console.log(value);
            }
        }(i))
    );
}
funcs.forEach(function(func){
    func(); //从 0 到 9 依次输出
});
/**
 * 以上写法在循环内使用了 IIFE. 变量 i 被传递给 IIFE,从而创建了 value 变量作为自身
 * 副本并将值存储于其中. value 变量的值被迭代中的函数所使用,因此在循环从 0 到 9 的过程中
 * 调用每个函数都返回了预期的值.幸运的是,使用 let 与 const 的块级绑定可以在 ES6 中为你简化
 * 这个循环.
 */

/**
 * 3.2循环内的 let 声明
 * let 声明通过有效模仿上例中 IIFE 的作用而简化了循环. 在每次迭代中,都会创建一个新的同名变量并对
 * 其进行初始化. 这意味着你可以完全省略IIFE而获得预期的结果,就像这样:
 */
var funcs = [];
for(let i = 0; i < 10; i++){
    funcs.push(
        function(){
            console.log(i);
        }
    );
}
funcs.forEach(
    function(func){
        func(); //从 0 到 9 依次输出
    }
)
/**
 * 与使用 var 声明以及 IIFE 相比,这里代码能达到相同效果,但无疑更加简洁. 在循环中 let 声明
 * 每次都创建了一个新的 i 变量,因此在循环内部创建的函数获得了各自的 i 副本,而每个 i 副本的值
 * 都在每次循环迭代声明变量的时候被确定了. 这种方式在 for-in 和 for-of 循环中同样适用.如下所示:
 */
var funcs = [],object = {
    a:true,
    b:true,
    c:true
};
for(let key in object){
    funcs.push(
        function(){
            console.log(key);
        }
    );
}
funcs.forEach(
    function (func) { 
        func(); //依次输出 "a", "b", "c"
    }
);
/**
 * 本例中的 for-in 循环提现出了与 for 循环相同的行为. 每次循环,一个新的 key 变量绑定就被创建,因此
 * 每个函数都能够拥有它自身的 key 变量副本,结果每个函数都输出了一个不同的值,而如果使用 var 来声明key,
 * 则所有函数都只有输出 "c".
 * 
 * 需要重点了解的是: let 声明在循环内部的行为是在规范中特别定义的,而与不提升变量声明的特征没有必然联系.
 * 事实上,在早期 let 的实现中并没有这种行为,它是后来才添加的.
 */

/**
 * 3.3循环内的常量声明
 * ES6规范没有明确禁止在循环中使用 const 声明,然而它会根据循环方式的不同而有不同行为.在常规的 for 循环中,
 * 你可以在初始化时使用 const,但循环会在你试图改变该变量的值是抛出错误.例如:
 */
var funcs = [];
//在一次迭代后抛出错误
for(const i = 0; i < 10; i++) {
    funcs.push(
        function(){
            console.log(i);
        }
    );
}
/**
 * 在此代码中, i 被声明为一个常量. 循环的第一次迭代成功执行,此时 i 的值为 0,在 i++ 执行是,一个错误会被抛出,
 * 因为该语句试图更改常量的值. 因此,在循环中你只能使用 const 来声明一个不会被更改的变量.
 * 
 * 而另一方面,const 变量在 for-in 或 for-of 循环中使用时,与 let 变量效果相同.因此下面代码不会导致出错:
 */
var funcs = [],object = {
    a:true,
    b:true,
    c:true
};
//不会导致错误
for(const key in object){
    funcs.push(
        function(){
            console.log(key);
        }
    );
}
funcs.forEach(
    function (func) { 
        func(); //依次输出 "a", "b", "c"
     }
);
/**
 * 这段代码与 "循环内的let声明"小节的第二个例子几乎完全一样,唯一的区别是 key 的值在循环内不能被更改.
 * const 能够在 for-in 与 for-of 循环内工作,是因为循环为每次迭代创建了一个新的变量绑定,而不是试图
 * 去修改已绑定的变量的值(就像使用了 for 而不是 for-in 的上个例子那样).
 */

/**
 * 4.全局块级绑定
 * let 与 const 不同于 var 的另一个方面是在全局作用域上的表现.当在全局作用域上使用var时,它会创建
 * 一个新的全局变量,并成为全局对象(在浏览器中是 window )的一个属性. 这意味着使用 var 可能会无意
 * 覆盖一个已有的全局属性,就像这样:
 */
var RegExp = "Hello!"; 
console.log(window.RegExp); // "Hello!"
var ncz = "Hi!";
console.log(window.ncz); // "Hi!"
/**
 * 尽管全局的 RegExp 是定义在 window 上的,它仍然不能防止被 var 重写. 这个例子声明了一个新的全局
 * 变量 RegExp 而覆盖了原有对象. 类似的, nca 定义为全局变量后就立即成为了 window 的一个属性. 这
 * 就是 JS 通常的工作方式.
 * 
 * 然而若你在全局作用域上使用 let 或 const, 虽然在全局作用域上会创建新的绑定,但不会有任何属性被添加
 * 到全局对象上. 这也就意味着你不能使用 let 或 const 来覆盖一个全局变量,你只能将其屏蔽.这里有个
 * 范例:
 */

//在浏览器中
let RegExp = "Hello!";
console.log(RegExp); // "Hello!"
console.log(window.RegExp === RegExp); //false
const ncz = "Hi!";
console.log(ncz); // "Hi!"
console.log("ncz" in window); // false
/**
 * 代码的 let 声明创建了 RegExp 的一个绑定,并屏蔽了全局的 RegExp. 这表示 window.RegExp 与
 * RegExp 是不同的,因此全局作用域没有被污染. 同样, const 声明创建了 ncz 的一个绑定,但并未在
 * 全局对象上创建属性. 当你不想在全局对象上创建属性时,这种特性会让 let 与 const 在全局作用域
 * 中更安全.
 * 
 * 若像让代码能从全局对象中被访问,你仍然需要使用 var. 在浏览器中跨越帧或窗口去访问代码时,这种
 * 做法非常普遍.
 */

/**
 * 5.块级绑定新的最佳实践
 * 在ES6的发展阶段,被广泛认可的变量声明方式是: 默认情况下应当使用 let 而不是 var.
 * 对于多数JS开发者来说, let 的行为方式正式 var 本应有的方式,因此直接用 let 替代
 * var 更符合逻辑.这这种情况下,你应当对需要受到保护的变量使用const.
 * 
 * 然而,随着更多的开发者迁移到ES6上,一种替代方案变得更为流行,那就是在默认情况下使用
 * const, 并且只在知道变量值需要被更改的情况下才使用 let. 其理论依据是大部分变量
 * 在初始化之后都不应当被修改,因为预期外的改动是bug的源头之一.
 */

/**
 * 总结
 * 
 * let 与 const 块级绑定将词法作用域引入了JS. 这两种声明方式都不会进行提升,并且
 * 只会在声明它们的代码块内部存在.由于变量能够在必要位置被准确声明,其表现更加接近
 * 其他语言,并且能减少无心错误的产生. 作为一个副作用,你不能在变量声明位置之前访问
 * 它们,即使使用的是 typeof 这样的安全运算符. 由于块级绑定存在暂时性死区(TDZ),
 * 试图在声明位置之前访问它就会导致错误.
 * 
 * let 与 const 的表现在很多情况下都相似于 var,然而在循环中就不是这样. 在 for-in
 * 与 for-of 循环中, let 与 const 都能在每一次迭代时创建一个新的绑定,这意味着在循环
 * 体内创建的函数可以使用当前迭代所绑定的循环变量值(而不是像使用 var 那样,统一使用循环
 * 结束时的变量值). 这一点在for循环中使用 let 声明时也成立,不过在for 循环中使用 const
 * 声明则会导致错误.
 * 
 * 块级绑定当前的最佳实践就是: 在默认情况下使用 const, 而只在你知道变量值需要被更改
 * 的情况下才使用 let. 这在代码中能确保基本层次的不可变性,有助于防止某些类型的错误.
 */