/**
 * 一个对象给其使用者提供了轻量,简单,强大的操作集.使用者
 * 与一个对象最基本的交互是获取其属性值和调用其方法.这些
 * 操作不是特别在意属性存储在原型继承结构的那个位置.
 * 随着时间的推移,实现对象是可能会将一个属性实现在对象原型链的不同位置.但是只要
 * 其值保持不变,那么这些基本操作的行为也不变. 简而言之,原型是一种对象行为的实现细节.
 * 
 * 与此同时,JavaScript提供了便利的内省机制(introspection mechanisms)来检查对象的
 * 细节. 
 * 1.Object.prototype.hasOwnProperty 方法确定一个属性是否为对象 "自己的" 属性 (即一个实例属性),
 *   而完全忽视原型继承结构.
 * 2.Object.getPrototypeOf 和 __proto__ 特性允许程序员遍历对象的原型链并单独查询其原型对象.
 *   这些特性是非常强大的,有时也是很有用的.
 * 
 * 但是,优秀的程序员知道什么时候考虑抽象边界. 检查实现细节(即使没有修改它们)也会在程序的组件之间
 * 创建依赖. 如果对象的生产这修改了实现细节, 那么依赖于这些对象的使用者就会被破坏. 很难诊断出这类
 * Bug, 因为它们构成了超距作用(action at a distance),即一个作者修改了一个组件的实现,导致另一个
 * 组件(通常由不同的程序员编写)被破坏.
 * 
 * 类似地,JavaScript并不区分对象的公有属性和私有属性.
 */

/**
 * 1.对象是接口,原型是实现.
 * 2.避免检查你无法控制的对象的原型结构.
 * 3.避免检查实现在你无法控制的对象内部的属性.
 */