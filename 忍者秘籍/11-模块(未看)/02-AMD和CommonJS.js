/**
 * AMD和CommonJS是两个相互竞争的标准,均可以定义JavaScript模块. 除了语法和原理的区别之外,
 * 主要的区别是AMD的设计理念是明确基于浏览器, 而CommonJS的设计是面向通过JavaScript环境
 * (如Node.js服务端),而不局限于浏览器.
 */

/**
 * 1. AMD
 * AMD最流行的实现是 RequireJS
 * 
 * 清单11.3 所示
 * 
 * AMD提供名为 define的函数,它接受以下参数.
 * - 新创建模块的ID. 使用该ID, 可以在系统的其他部分引用该模块.
 * - 当前模块依赖的模块ID列表
 * - 初始化模块的的工厂函数, 该工厂函数接受依赖的模块列表作为参数.
 * 
 * 在本例中,我们使用AMD的 define函数定义ID为 MouseCounterModule 的模块.
 * 该模块依赖于 jQuery. 因为依赖于 jQuery, 因此AMD首先请求 jQuery模块,如果需要从
 * 服务端请求,那么这个过程将会花费一些时间. 这个过程是异步执行的,以避免阻塞. 所有
 * 依赖的模块下载并解析完成之后,调用模块的工厂函数,并传入所依赖的模块. 在本例中,
 * 只依赖一个模块,因此传入一个参数 jQuery. 在工厂函数内部,是与标准模式类似的创建模块的
 * 过程: 创建暴露模块公共接口的对象.
 * 
 * 可以看出, AMD有以下几项有点:
 * - 自动处理依赖, 我们无需考虑模块引入的顺序
 * - 异步加载模块,避免阻塞.
 * - 在同一个文件中可以定义多个模块.
 */

/**
 * 2. CommonJS
 * AMD的设计明确基于浏览器,而CommonJS的设计是面向通用JavaScript环境. CommonJS目前在Node.js
 * 社区具有最多的用户. CommonJS使用基于文件的模块,所以每个文件中只能定义一个模块. CommonJS提供
 * 变量module, 该变量具有属性 exports, 通过exports可以很容易地扩展额外属性. 最后, module.exports
 * 作为模块的公共接口.
 * 
 * 如果希望在应用的其他部分使用模块,那么可以引用模块. 文件同步加载,可以访问模块公共接口. 这是CommonJS
 * 在服务端更流行的原因,模块加载相对更快,只需要读取文件系统,而在客户端则必须从远程服务器下载文件,同步
 * 加载通常意味着阻塞.
 * 
 * 再看看如何使用CommonJS定义MouseCounterModule模块, 如清单 11.4 所示.
 * 
 * 清单11.4 -使用CommonJS定义模块
 * 
 * 由于CommonJS要求一个文件是一个模块,文件中的代码就是模块的一部分. 因此,不需要使用立即执行函数来包装变量.
 * 在模块中定义的变量都是安全地包含在当前模块中,不会泄露到全局作用域. 例如,
 * 模块变量 ( $, numClicks 和 handleClick )虽然是在模块代码顶部 (在函数或代码块外部) 定义的,但是仍然
 * 在模块作用域中; 如果在标准JavaScript文件中这样的写法将会生成全局变量.
 * 
 * 再次强调, 只有通过 module.exports 对象暴露的对象或函数才可以在模块外部访问. 这个过程与模块模式的类似,唯一
 * 的区别是无需返回一个全新的对象,模块已经提供了扩展接口和属性的方法.
 * 
 * CommonJS具有两个优势: 
 * 1. 语法简单. 只需定义module.exports属性,剩下的模块代码与标准JavaScript无差异. 引用模块的方法也很简单,
 * 只需要使用 require 函数.
 * 2. CommonJS是Node.js默认的模块格式,所以我们可以使用 npm 上成千上万的包.
 * 
 * 
 */