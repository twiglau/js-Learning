/**
 * 每个函数都有一个原型对象, 该原型对象将被自动设置为通过该函数创建对象的原型.
 * 
 * 查看清单7.2   通过原型方法创建新的实例
 * 
 * 我们通过new操作符调用该函数, 此次是作为构造器进行调用,发生了完全不同的事情. 再次调用这个函数,
 * 但这一次已经创建了新分配的对象, 并将其设置为函数的上下文(可通过this关键字访问). 操作符 new 返回
 * 的结果是这个新对象的引用. 然后我们测试 ninja2 是新创建的对象的引用, 具有swingSword方法,并调用
 * swingSword方法.
 * 
 * 图7.4, 可查看应用程序状态
 * 
 * - 每一个函数都具有一个原型对象
 * - 每一个函数的原型都具有一个 constructor 属性, 该属性指向函数本身.
 * - constructor对象的原型设置为新创建的对象的原型.
 * 
 * 从图7.4可以看出, 我们创建的每一个函数都具有一个新的原型对象. 最初的原型对象只有一个属性, 即 constructor属性.
 * 该属性指向函数本身
 */

/**
 * 1. 实例属性
 * 当把函数作为构造函数, 通过操作符new进行调用时, 它的上下文被定义为新的对象实例. 通过原型暴露属性,通过
 * 构造函数的参数进行初始化.
 * 
 * 清单7.3检查使用这种方法创建的实例的属性. 
 * 观察初始化过程的优先级
 * 
 * - 实例会隐藏原型中与实例方法重名的方法, 如图7.5所示.
 * 
 * 在构造函数内部, 关键字this指向新创建的对象, 所以在构造器内添加的属性直接在新的ninja实例上. 然后,当通过ninja访问
 * SwingSword属性时, 就不需要遍历原型链(如图 7.4所示),就立即可以找到并返回了在构造器内创建的属性
 * 
 * 这里有一个很有意思的副作用. 图7.6展示了当创建3个ninja实例之后程序的状态
 * 
 * 如图7.6所示
 * 
 * 正如你所看到的,每个ninja实例都有自己的属性版本,这些属性在构造器内创建,并且均可访问相同的原型属性. 这一点对于所有实例对象
 * 都是固定的属性值是没有影响的(如swung). 但是,在某些情况下对于对象方法来说可能是有问题的.
 * 
 * 在本例中, 我们有3个版本的swingSword方法,都执行相同的逻辑. 只创建几个对象影响不大, 但是如果创建大量的对象时就需要引起注意了.
 * 因为每个赋值的方法都一样,创建大量重复拷贝毫无意义, 仅仅是消耗了更多内存. 当然,一般来说JavaScript引擎可能执行一些优化,但是
 * 不能依赖JavaScript引擎. 从这个角度来看,只在函数的原型上创建对象方法是很有意义的, 这样我们可以使得同一个方法有所有对象实例
 * 共享.
 */

/**
 * 2. JavaScript动态特性的副作用
 * JavaScript是一门动态语言, 可以很容易地添加,删除和修改属性. 这种特性同样适用于原型,包括函数原型和对象原型.
 * 
 * 清单7.4 通过原型, 一切都可以在运行时修改
 * 
 * 我们定义了Ninja构造器, 继续使用它来创建一个对象实例. 此时程序的状态如图
 * 如图7.7所示
 * 
 * 实例对象创建完成之后, 我们在原型上添加swingSword方法. 通过执行测试来验证可以在对象创建完成之后,修改该对象
 * 的原型. 此时程序的状态
 * 如图7.8所示
 * 
 * 然后,我们使用字面量对象完全重写Ninja的原型对象, 该字面量对象仅含有pierce方法. 这对应用程序状态的影响
 * 如图7.9所示
 * 
 * 如图7.9所示,即使Ninja函数不再指向旧的Ninja原型, 但是旧的原型仍然存在于ninja1的实例中, 通过原型链仍然能够访问
 * swingSword方法. 但是,如果我们在Ninja发生这些变化之后再创建新的实例对象,此时应用程序的状态
 * 如图7.10所示
 * 
 * 对象与函数原型之间的引用关系是在对象创建时建立的. 新创建的对象将引用新的原型, 它只能访问pierce方法,原来旧的对象
 * 保持着原有的原型,仍然能够访问swingSword方法.
 */

/**
 * 3. 通过构造函数实现对象类型
 * 通过使用constructor属性,我们可以访问创建该对象时所用的函数. 这个特性可以用于类型校验.
 * 
 * 如清单7.5所示
 * 
 * 我们首先定义一个构造器,并使用该构造器创建一个实例对象. 然后使用操作符 typeof 检查该实例对象的类型. 这也发现不了什么,
 * 因为所有的实例都是对象类型, 所以返回的类型总是对象. 更有趣的是操作符 instanceof, 它提供了一种用于检测一个实例是否由
 * 特定构造函数创建的方法.
 * 
 * 此外,我们可以使用constructor属性,所有的实例对象都可以访问constructor属性,constructor属性是创建实例对象的函数的
 * 引用. 我们可以使用 constructor 属性验证实例的原始类型 (与操作符 instanceof 非常类似)
 * 
 * 由于constructor属性仅仅是原始构造函数的引用, 因此我们可以使用该属性创建新的Ninja对象,
 * 如清单7.6所示 - 使用constructor的引用创建新对象
 * 
 * 这里我们定义了一个构造器, 并使用该构造器创建了一个实例对象. 然后我们使用该实例对象的 constructor属性创建第二个实例.
 * 验证表明第二个Ninja对象被创建成功, 并且第二个实例与第一个实例对象是截然不同的两个实例.
 */