/**
 * 处理JavaScript函数上下文时可能遇到的一些问题.在回调函数中(例如事件处理器),
 * 函数上下文与预期不符,但可以使用call或apply方法绕过. 在本节中,看看另外两个选择: 箭头
 * 函数和bind方法,在一些情况下可以更优雅地实现相同的效果.
 */

/**
 * 1. 使用箭头函数绕过函数上下文
 * 箭头函数作为回调函数还有一个更优秀的特性: 箭头函数没有单独的 this 值. 箭头函数的 this
 * 与声明所在的上下文的相同.
 * 
 * 查看清单 listing-4.2 
 * 
 * 调用箭头函数时, 不会隐式传入this参数,而是从定义时的函数继承上下文. 在本例中,箭头函数
 * 在构造函数内部, this指向新创建的对象本身,因此无论何时调用click函数,this都将指向新
 * 创建的button对象.
 * 
 * 警告: 箭头函数 和 对象字面量
 * 由于 this 值是在箭头函数创建时确定的,所以会导致一些看似奇怪的行为.回到按钮单击实例中,因为
 * 只有一个按钮,因此可以假设不需要构造函数. 直接使用对象字面量.
 * 
 * 查看清单 listing-4.3
 * 
 * 在全局代码中定义对象字面量,在字面量中定义箭头函数,那么箭头函数内的 this 指向全局 window 对象.
 */

/**
 * 2. 使用 bind 方法
 * 无论使用哪种方法调用, bind方法创建的新函数与原始函数的函数体相同, 新函数被绑定到指定的对象上.
 * 
 * 查看清单 listing-4.4
 * 
 * 清单4.4 的代码的秘诀在于使用 bind() 方法: 
 * elem.addEventListener("click",button.click.bind(button));
 * 所有函数均可访问bind方法,可以创建并返回一个新函数,并绑定在传入的对象上(在本例中,绑定在 button 对象上).
 * 不管如何调用该函数, this 均被设置为对象本身. 被绑定的函数与原始函数行为一致, 函数体一致.
 * 
 * 无论何时单击按钮,都将调用绑定的函数,函数的上下文是 button 对象.
 * 
 * 从实例代码中的最后一句断言可以看出, 调用bind方法不会修改原始函数,而是创建了一个全新的函数: 
 * var boundFunction = button.click.bind(button);
 * assert(boundFunction != button.click,"Calling bind creates a completly new function");
 */