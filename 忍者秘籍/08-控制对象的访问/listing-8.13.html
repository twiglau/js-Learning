<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>检查代理的性能限制</title>
		<link rel="stylesheet" href="../assert.css">
		<script src="../assert.js"></script>
	</head>
	<body>
		<script>
			function createNegativeArrayProxy(array){
				if(!Array.isArray(array)){
					throw new TypeError('Expected an array');
					//如果传入的参数不是数组,则抛出异常
				}

				return new Proxy(array,{
					//返回新的代理,该代理使用传入的数组作为代理目标
					get: (target,index) => {
						//当读取数组元素时调用get方法
						index = +index;//使用一元 + 操作符将属性名变成的数值
						return target[index < 0 ? target.length + index : index];
						// 如果访问的是负向索引,则逆向访问数组. 如果访问的是正向索引,则正常访问数组
					},
					set: (target,index,val) => {
						//当写入数组元素时, 调用set方法
						index = +index;
						return target[index < 0 ? target.length + index : index] = val;
					}
				});
			}
			function measure(items){
				const startTime = new Date().getTime(); //在一个长时间运行的循环中访问集合中的元素

				for(let i = 0; i < 500000; i++){
					items[0] = "Yoshi";
					items[1] = "Kuma";
					items[2] = "Hattori";
				}// 在执行循环体之前获取当前时间

				return new Date().getTime() - startTime; // 测量循环体的执行时间
			}

			const ninjas = ["Yoshi","Kuma","Hattori"];
			const proxiedNinjas = createNegativeArrayProxy(ninjas); 
			//比较标准数组访问和通过代理访问的执行时间差异

			console.log("Proxies are around", Math.round(measure(proxiedNinjas) / measure(ninjas)),"times slower");

		</script>
	</body>
</html>
