/**
 * 代理(proxy)是我们通过代理控制对另一个对象的访问. 通过代理可以定义当对象发生交互时可执行
 * 的自定义行为 -- 如读取或设置属性值,或调用方法. 可以将代理理解为通用化的 setter 与 getter,
 * 区别是每个 setter 与 getter 仅能控制单个对象属性, 而代理可用于对象交互的通用处理,包括
 * 调用对象的方法.
 * 
 * 过去使用 setter 与 getter 处理日志记录,数据校验,计算属性等操作,均可使用代理对它们进行处理.
 * 代理更加强大. 使用代理, 我们可以很容易地在代码中添加分析和性能度量;
 * 自动填充对象属性以避免讨厌的Null异常; 包装宿主对象, 例如DOM用于减少浏览器的不兼容性.
 * 
 * 清单8.7  通过Proxy构造器创建代理
 * 
 * 使用代理对象的要点: 
 * 通过Proxy构造器创建代理对象, 代理对象访问目标对象时执行指定的操作.
 * 
 * 在本例中,我们使用 get 与 set, 还有许多其他的内置方法用于定义各种对象的行为.例如: 
 * - 调用函数时激活apply, 使用new操作符时激活construct.
 * - 读取/写入属性时激活get与set.
 * - 执行for-in语句时激活enumerate.
 * - 获取和设置属性值时激活 getPrototypeOf() 与 setPrototypeOf()
 * 
 * 我们可以拦截许多操作, 主要查看实例: 
 * 相等(== 或 ===), instanceof 以及 typeof 操作符
 */

/**
 * 1. 使用代理记录日志
 * 先回顾之前使用的例子,
 * 
 * 清单8.8所示
 * 注意到这并不是最理想的解决方案, 这混合了对象睡醒读写的代码与日志代码. 此外,如果将来我们需要ninja对象更多
 * 的属性, 我们不得不小心翼翼地为每个属性都添加日志记录语句.
 * 
 * 幸好,代理的直接用途之一是在我们读写属性时使用一种更好的, 更清洁的方式启用日志记录
 * 
 * 考虑清单8.9的示例 -使用代理更易于在对象上添加日志
 * 
 * 这种日志记录方式比使用标准的getter活setter方法更容易,更透明. 我们不会把原有代码与日志代码混淆, 也不需要为每个
 * 对象属性添加单独的日志. 所有读写属性的操作都会进入代理方法. 记录日志的代码只需在一处指定, 无论读写睡醒多少次, 无论属性
 * 增加多少, 都可以记录对应的日志
 * 
 */

/**
 * 2. 使用代理检测性能
 * 除了用于记录属性访问日志之外, 代理还可以在不需要修改函数代码的情况下, 评估函数调用的性能.
 * 例如, 我们想要评估计算一个数值是否是素数的函数的性能
 * 
 * 清单8.10  使用代理评估性能
 * 
 * 现在想象一下我们需要评估isPrime函数的性能,并且不能修改该函数的代码. 我们可以使用代理包装该函数,添加一个一旦调用
 * 该函数就会被触发的方法: 
 * isPrime = new Proxy(isPrime, {
 *     apply: (target,thisArg,args) => {
 *       ...
 *     }
 * });
 * 
 * 使用isPrime函数作为代理的目标对象. 同时,添加apply方法,当调用isPrime函数时就会调用 apply 方法.
 * 
 * 与之前的示例类似, 我们将新创建的代理对象赋值给isPrime表示符. 这样, 我们无需修改isPrime函数内部代码,
 * 就可以调用apply方法实现isPrime函数的性能评估, 程序代码的其余部分可以完全无视这些变化.
 * 
 * 每当调用isPrime函数时,都会进入代理的 apply 方法, 开启内置的 console.time 方法秒表计时, 调用原始的
 * isPrime函数, 记录运行时间, 最后返回isPrime调用的结果.
 */

/**
 * 3. 使用代理自动填充属性
 * 除了简化日志, 代理还可用于自动填充属性. 例如, 假设需要抽象计算机的文件夹结构模型, 一个文件夹对象即可以有属性,
 * 也可以是文件夹. 现解设你需要长路径的文件模型,如: 
 * 
 * rootFolder.ninjasDir.firstNinjaDir.ninjaFile = "yoshi.txt";
 * 
 * 为了创建这个长路径文件模型, 你可能会按照以下思路设计代码: 
 * 
 * const rootFolder = new Folder();
 * rootFolder.ninjasDir = new Folder();
 * rootFolder.ninjasDir.firstNinjaDir = new Folder();
 * rootFolder.ninjasDir.firstNinjaDir.ninjaFile = "yoshi.txt";
 * 
 * 似乎有点不必要的繁琐, 不是吗? 这时就需要自动填充属性登场, 看看清单8.11 的例子
 * 
 * 清单8.11 使用代理自动填充属性
 * 
 * 通常情况下,我们思考如下代码, 预期是抛出一个异常: 
 * const rootFolder = new Folder();
 * rootFolder.ninjasDir.firstNinjaDir.ninjaFile = "yoshi.txt";
 * 
 * 我们访问ninjasDir上未定义的属性 firstNinjaDir. 但是当我们执行代码时会发现,一切都运行正常.
 * 
 * 正是因为我们使用了代理,所以每次访问属性时, 代理方法都被激活. 如果访问的属性在文件夹对象存在,则
 * 直接返回对应的值; 如果不存在, 将会创建新的文件夹并赋值给该属性. 这是ninjasDir 与 firstNinjaDir
 * 属性被创建的原因.
 */

/**
 * 4. 使用代理实现负数组索引
 * 你可能习惯了数组的负索引,它使得你可以使用负索引来逆向检索数组元素,代码如下: 
 * const ninjas = ["Yoshi","Kuma","Hattori"];
 * 
 * ninjas[0]; //"Yoshi"
 * ninjas[1]; //"Kuma"
 * ninjas[2]; //"Hattori" //使用正索引
 * 
 * ninjas[-1]; //"Hattori"
 * ninjas[-2]; //"Kuma"
 * ninjas[-3]; //"Yoshi" //使用负索引,如为-1, 则返回最后一项数组元素
 * 
 * 遗憾的是, JavaScript不支持数组负索引, 但是,我们可以使用代理进行模拟. 为了研究这个概念,我们来
 * 看看Sindre Sorhus 写的一个稍微简化版本的代码(https://github.com/sindresorhus/negative-array),
 * 
 * 如清单8.12所示  使用代理实现数组负索引
 */

/**
 * 5. 代理的性能消耗
 * 我们已经知道,代理是我们通过代理对象控制对另一个对象的访问. 代理可以定义执行特定操作时同时调用的方法. 并且,你
 * 已经看到, 我们可以使用代理方法实现有用的功能, 如日志记录, 性能评估, 自动填充属性,数组负索引等.
 * 遗憾的是, 代理也要缺陷. 事实上, 我们所有的操作都通过代理添加了一个间接层, 使我们能够实现所有这些
 * 很酷的特性, 但与此同时它引入了大量的额外的处理,会影响性能.
 * 
 * 为了测试性能问题, 我们利用清单8.12的数组负索引的示例, 比较正常数组访问元素时的执行时间 和 通过代理数组访问元素的
 * 执行时间.
 * 
 * 如清单 8.13 所示   -> 检查代理的性能限制
 * 
 * 在Chrome浏览器, 代理数组的执行时间大约为正常数组的 50倍,在Firefox浏览器大约为20倍.
 * 
 * 现在,我们建议谨慎使用代理. 尽管使用代理可以创造性地控制对象的访问, 但是大量的控制操作将带来性能问题. 可以在多性能
 * 不敏感的程序里使用代理, 但是若多次执行代码时仍然要小心谨慎.
 */