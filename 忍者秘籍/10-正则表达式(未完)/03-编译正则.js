/**
 * 两个主要的阶段是 编译 和 执行.
 * 编译阶段发生在正则表达式被创建的时期. 执行阶段发生在使用编译之后的正则表达式
 * 进行匹配字符串的时期.
 * 
 * 在编译过程中, 表达式经过JavaScript引擎的解析, 转换为内部代码. 解析和转换的过程
 * 发生在正则表达式创建时期(浏览器会进行内部优化处理工作)
 * 
 * 通常来说,浏览器会只能判断使用哪条正则表达式,并缓存该表达式的编译结果. 但是我们不指望
 * 全部类型的浏览器都能做到这么只能的处理. 尤其对于复杂的表达式,我们可以通过预定义
 * (预编译) 正则表达式, 使得性能得到明显提升.
 * 
 * 清单10.2 创建正则表达式的两种方法
 * 
 * 在本例中,两个正则表达式在创建后都处于编译后的状态. 可以使用任何标识符来代替 res1 指向
 * 字面量 /test/i, 每次都会编译相同的正则表达式. 因此,编译一次正则表达式,并将其保存在变量
 * 中是很重要的优化过程.
 * 
 * 请注意, 每个正则表达式都有一个独特的对象表示: 每次创建一个正则表达式(也被编译) 都会创建
 * 一个新的正则表达式对象. 这与原始类型( 如string, number 等) 不同, 因为每个正则对象永远
 * 是独一无二的.
 * 
 * 特别重要的是, 通过使用构造函数创建正则表达式(new RegExp(...)),我们可以在运行时使用字符串创建
 * 正则表达式. 这对于构建可以重复使用的复杂正则表达式非常有用.
 * 
 * 例如, 假设我们需要确定文档中哪些元素具有指定 class 名, 而 class 的具体值在运行时才能确定. 
 * 由于每个元素可以绑定多个 class (存储在使用空格分割的字符串中), 这是运行时正则表达式编译的有趣示例
 * 
 * 清单10.3 在运行时编译一个供稍后使用的正则表达式
 * 
 * 从清单10.3中. 首先, 我们创建一组用于测试的 <div> 和 <span> 元素, 这些元素具有不同class 然后我们
 * 定义class校验函数, 接收class作为参数,校验元素是否含有该class.
 * 
 * 然后,我们通过内置的 getElementsByTagName 方法查找匹配的元素类型,创建正则表达式: 
 * > const regex = new RegExp("(^|\\s)" + className + "(\\s|$)");
 * 
 * 注意,使用new RegExp()构造器时,是基于传入的 class 名称进行编译正则表达式的. 这是无法使用正则字面量的
 * 场景示例, 因为无法提前预知所需查找的 class 名称.
 * 
 * 我们立即创建(然后编译)正则表达式,是为了避免不必要的,频繁地重复编译.由于表达式是动态生成的(基于传入的className参数),
 * 可以看出这种方式节省大量的性能开销.
 * 
 * 该正则表达式匹配字符串开始或空格,接着是指定的class名称,最后以空格或字符串结束. 注意在正则\\s中双反斜线(\\)
 * 的使用. 当使用反斜线创建正则表达式字面量时,只需使用一个反斜线. 但是由于在字符串中写反斜线,必须使用双反斜线进行
 * 转义
 * 
 * 
 */