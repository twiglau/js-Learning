/**
 * 在JavaScript中,我们可以通过 3 个关键字定义变量: 
 * var, let  和 const. 这3个关键字有两点不同: 可变性, 与词法环境的关系
 */

/**
 * 1. 变量可变性
 * 如果通过变量的可变性来进行分类,那么可以将const放在一组, var 和 let 放在一组. 通过
 * const定义的变量都不可变, 也就是说通过 const 声明的变量的值只能设置一次.
 * 通过var或let声明的变量的值可以便跟任意次数.
 * 
 * 现在,来深入了解下通过 const 声明的变量是如何工作的.
 * 
 * const 变量
 * 通过const声明的 "变量" 与普通变量类似, 但在声明时需要写初始值,一旦声明完成之后,其值就无法更改.
 * 听起来它不可变
 * 
 * -> const 变量常用于两种目的: 
 * 
 * > 不需要重新赋值的特殊变量
 * > 指向一个固定的值,例如球队人数的最大值,可通过const变量 MAX_RONIN_COUNT来表示,而不是仅仅通过
 * 数字 234 来表示. 这使得代码更加易于理解和维护
 * 
 * 清单5.6显示了 const 变量为行为
 * 
 * const变量只能在声明时被初始化一次,之后再也不允许将全新的值赋值给 const 变量即可. 但是,我们仍然
 * 可以修改 const 变量已经存在的值,只是不能重写 const 变量.
 */


/**
 * 2. 定义变量的关键字  与 词法环境
 * 定义变量的3个关键字 -- var, let 与 const, 还可以通过与词法环境的关系将其进行分类(换句话说,按照作用域分类):
 * 可以将var分为一组, let与const分为一组.
 * 
 * > 使用关键字var时, 该变量是在距离最近的函数内部或是在全局词法环境中定义的.
 * (注意: 忽略块级作用域) 这是JavaScript由来已久的特性,也困扰了许多从其他语言转向JavaScript的开发者.
 * 见清单 5.7
 * 
 * 解释: 
 * > 2.1. 我们首先定义全局变量 globalNinja, 接着定义函数 reportActivity,在该函数中使用循环并验证变量 globalNinja
 * 的行为. 可以看出,在循环体内可以正常访问: 
 * 块级作用域中的变量(变量 i 与 forMessage), 函数体内的变量(functionActivity) 以及
 * 全局变量(globalNinja)
 * 
 * 但是JavaScript中特殊的并使得许多从其他语言转向 JavaScript的开发者困惑的是, 即使在块级作用域内定义的变量,在块级
 * 作用域外仍然能够被访问
 * 
 * 这源于通过var声明的变量实际上总是在距离最近的函数内或全局词法环境中注册的, 不关注块级作用域. 图5.11描述了这一现象,
 * 图中展示了 reportActivity 函数内的 for 循环执行后的词法环境.
 * 
 * 图5.11 示例
 * 
 * > 2.2. 这里有3众词法环境: 
 * - 变量globalNinja是在全局环境中定义的(距离最近的函数内或全局词法环境).
 * - reportActivity函数创建的函数环境,包含变量functionActivity,i 与 forMessage,这3个变量均通过关键字 var 定义的,
 * 与它们距离最近的是 reportActivity 函数.
 * - for循环的块级作用域,关键字var定义的变量忽略块级作用域.
 * 
 * 这种行为看起来有些怪异, 因此, ES6中提供了两个新的声明变量的关键字: let 与 const.
 * 
 * 2.1 使用 let 与 const 定义具有块级作用域的变量
 * var 是在距离最近的函数或全局词法环境中定义变量, 与var不同的是, let和const更加直接.
 * let和const直接在最近的词法环境中定义变量( 可以是在块级作用域内,循环内,函数内或全局环境内). 我们可以使用 let和const定义
 * 块级别,函数级别,全局级别的变量.
 * 
 * 让我们使用 const 与 let 重写之前的实例, 清单5.8所示
 * //Using const and let keywords
 * 
 * 图5.12展示了 reportActivity函数内的 for 循环执行完成之后的词法环境. 此时我们仍然看到3个词法环境: 
 * 全局环境(函数和块级作用域之外的全局代码), reportActivity函数环境 和 for循环体. 
 * 但是由于我们使用了关键字 let 和 const, 那么变量则是在距离最近的词法环境中定义的: 
 * -> 变量GLOBAL_NINJA是在全局环境中定义的,
 * -> 变量functionActivity是在函数reportActivity中定义的,
 * -> 变量 i 与 forMessage 是在for循环的块级作用域中定义的.
 * 
 * 我们理解了词法环境中是如何保存标识符的映射表, 理解了词法环境与程序执行的关系,那么接下来讨论在词法环境中定义的标识符的
 * 准确的处理过程.
 */

/**
 * 3. 在词法环境中注册标识符
 * JavaScript作为一门编程语言,其设计的基本原则是易用性. 这也是不需要指定函数返回值类型,函数参数类型,变量类型等的主要原因.
 * 你已经了解到JavaScript是逐行执行的,查看如下
 * firstRonin = "Kiyokawa";
 * secondRonin = "Kondo";
 * 
 * 将KiyoKawa赋值给标识符firstRonin, 将Kondo赋值给标识符secondRonin.看起来没有什么
 * 特殊的地方,接着,
 * const firstRonin = "Kiyokawa";
 * check(firstRonin);
 * function check(ronin){
 *    assert(ronin === "Kiyokawa","The ronin was checked!");
 * }
 * 
 * 在本例中, 我们将值Kiyokawa 赋给 firstRonin, 然后调用 check 函数, 传入参数 firstRonin. 先等一下,如果JavaScript是逐行执行的,
 * 我们此时可以调用 check 函数吗? 程序还没执行到函数check的声明,所以JavaScript引擎不应该认识 check 函数.但是,程序运行得很顺利.
 * 
 */

/**
 * 3.1 注册标识符的过程
 * 但除了易用性, 代码入额逐行执行, JavaScript引擎是如何知道check函数存在呢? 这说明JavaScript引擎耍了小把戏,JavaScript代码的
 * 执行事实上是分两个阶段进行的.
 * 
 * 一旦创建了新的词法环境, 就会执行第一阶段.
 * 在第一阶段,没有执行代码,但是JavaScript引擎会访问并注册在当前词法环境中所声明的变量和函数.JavaScript在第一阶段
 * 完成之后开始执行第二阶段, 具体如何执行取决于变量的类型(let, var, const 和 函数声明) 以及环境类型(全局环境, 函数环境 或块级作用域)
 * 
 * 具体的处理过程如下: 
 * 
 * i. 如果是创建一个函数环境, 那么创建形参及函数参数的默认值. 如果是非函数环境, 将跳过此步骤.
 * 
 * ii. 如果是创建全局或函数环境, 就扫描当前代码进行函数声明(不会扫描其他函数的函数体), 但是不会扫描函数表达式 或 箭头函数. 对于所找到的函数声明,
 * 将创建函数, 并绑定到当前环境 与 函数名相同的标识符上. 若该标识符已经存在, 那么该标识符的值将被重写.
 * 如果是块级作用域, 将跳过此步骤.
 * 
 * iii. 扫描当前代码进行变量声明. 在函数 或 全局环境中, 找到所有当前函数以及其他函数之外通过 var 声明的变量,并找到所有在其他函数 或 代码块之外
 * 通过 let 或 const 定义的变量. 在块级环境中, 仅查找当前块中通过 let 或 const 定义的变量. 对于所查找的变量, 若该标识符不存在, 进行注册并将
 * 其初始化为 undefined. 若该标识符已经存在, 将保留其值.
 * 
 * 整个处理过程如图 5.14 所示.
 * 
 * 为什么可以在函数声明之前调用函数开始理解?
 * 
 */

/**
 * 3.2 在函数声明之前调用函数
 * JavaScript易用性的一个典型特征, 是函数的声明顺序无关紧要. 在JavaScript中,
 * 我们可以在函数声明之前对其进行调用.
 * 
 * 查看清单5.9中的代码
 * 
 * 我们甚至可以在函数定义之前访问函数. 我们可以这么做的原因是 fun 是通过函数声明进行定义的, 
 * 第二阶段表明函数已通过函数声明进行定义,在当前词法环境创建时已在
 * 其他代码执行之前注册了函数标识符. 所以,在执行函数调用之前, fun函数已经存在.
 * 
 * JavaScript引擎通过这种方式为开发者提供便利,允许我们直接使用函数的引用, 而不需要强制指定函数的定义顺序.在
 * 代码执行之前,函数已经存在了.
 * 
 * 需要注意的是,这种情况仅针对函数声明有效. 函数表达式与箭头函数都不在此过程中,而是在程序执行过程中执行定义的.
 * 这就是不能访问 myFunExp 与 myArrow 函数的原因.
 */

/**
 * 3.3 函数重载
 * 第二个难题是处理重载函数标识符的问题, 如清单 5.10 所示
 * 
 * 在清单 5.10 的示例中,声明的变量与函数均使用相同的名字fun. 如果你执行这段代码会发现,两个断言assert都通过了.
 * 在第一个断言中,标识符fun指向一个函数; 在第二个断言中, 标识符fun指向一个数字.
 * 
 * JavaScript的这种行为是由标识符注册的结果直接导致的. 
 * 在处理过程的第2步中, 通过函数声明进行定义的函数在代码执行之前对函数进行创建,并赋值给对应的标识符;
 * 在第3步,处理变量的声明,那些在当前环境中未声明的变量,将被赋值为 undefined.
 * 
 * 在清单5.10的示例中,在第2步 -- 注册函数声明时,由于标识符fun已经存在,并为被赋值为 undefined.
 * 这就是第1个测试fun是否是函数的断言执行通过的原因. 之后,执行赋值语句 var fun = 3, 将数字3赋值给标识符fun.
 * 执行完这个赋值语句之后,fun就不再指向函数了,而是指向数字3.
 * 
 * 在程序的实际执行过程中,跳过了函数声明部分,所以函数的声明不会影响标识符fun的值.
 */

/**
 * 变量提升 [variable hoisting]
 * 如果你已阅读关于解释处理标识符的一些 JavaScript 博客或图书,你可能已经遇到这个词: 变量提升.
 * 例如, 变量的声明提升至函数顶部, 函数的声明提升至全局代码顶部.
 * 
 * 但是,正如上述实例中看见的,并没有那么简单. 变量和函数的声明并没有实际发生移动. 只是在代码执行之前,先在
 * 词法环境中进行注册. 虽然描述为提升了,并且进行了定义, 这样更容易理解JavaScript的作用域的工作原理,但是,我们
 * 可以通过词法环境对整个处理过程进行更深入地理解.了解真正的原理.
 */