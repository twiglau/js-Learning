/**
 * 闭包可以访问创建函数时所在作用域内的全部变量, 还介绍了几种闭包有用的方法. 例如,通过闭包模拟
 * 私有变量,通过回调函数使得代码更加优雅.
 * 
 * 闭包与作用域密切相关. 闭包对JavaScript的作用域规则产生了直接影响.
 */

/**
 * 1. 回顾使用闭包模拟私有变量的代码
 * 回顾以下私有变量的示例,这次,我们将关注执行上下文与词法环境. 查看清单5.11
 * 
 * 现在, 我们分析第一个Ninja对象创建完成之后程序的状态, 如图5.15所示, 我们可以利用标识符原理
 * 来更好地理解这种情况之下闭包的工作原理. JavaScript构造函数是通过关键字 new 调用的函数. 
 * 因此,每次调用构造函数时, 都会创建一个新的词法环境,该词法环境保持构造函数内部的局部变量.
 * 在本例中,创建了Ninja环境, 保持对变量 feints 的跟踪.
 * 
 * 此外,无论何时创建函数,都会保持词法环境的引用(通过内置 [[Environment]] 属性). 在本例中,
 * Ninja构造函数内部,我们创建了两个函数: getFeints 与 feint, 均有Ninja环境的引用,因为Ninja
 * 环境是这两个函数创建时所处的环境.
 * 
 * getFeints 与 feint 函数是新创建的 ninja 的对象方法(如前文所述,可通过this关键字访问).因此,
 * 可以在Ninja构造函数外部访问 getFeints 与 feint 函数, 这样实际上就创建了包含 feints 变量
 * 的闭包.
 * 
 * 当再创建一个Ninja的实例,即ninja2 对象时,将重复整个过程. 图5.16 显示了创建第二个Ninja
 * 对象之后的程序状态.
 * 
 * 每个通过Ninja构造函数创建的对象实例均获得了各自的方法 (ninja1.getFeints 与 ninja2.getFeints 是
 * 不同的), 当调用构造函数时, 各自的实例方法包含各自的变量. 这些 "私有变量" 只能通过构造函数内定义的
 * 对象方法进行访问, 不允许直接访问. 现在让我们看看当 ninja2.getFeints 方法调用时发生了什么.
 * 图5.17 显示了细节
 * 
 * 当调用 ninja2.getFeints()时, 我们调用的是ninja2对象的getFeints方法. 由于每次调用函数时均会创建新的执行上下文,
 * 因此创建了新的getFeints执行环境并推入执行栈. 这同时引起创建新的词法环境, 词法环境通常用于保持跟踪函数中定义的变量.
 * 另外, getFeints词法环境包含了getFeints函数被创建时所处的环境, 当ninja2对象构建时,Ninja环境是活跃的.
 * 
 * 现在让我们来了解试图获取feints变量时是如何工作的. 首先,访问活跃的getFeints词法环境. 因为在getFeints函数内部未定义
 * 任何变量, 该词法环境是空的,找不到feints变量. 接下来,在当前词法环境的外部环境进行查找 --- 本例中,当创建ninja2对象时,
 * Ninja环境处于活跃状态. Ninja环境中具有feints 变量的引用, 完成搜索过程, 就是那么简单.
 * 
 * 我们理解了在处理闭包是,执行上下文与词法环境所扮演的角色,那么接下来,我们将关注 "私有" 变量, 为什么要保持 "私有" 变量的引用.
 * 可能你已经发现了, 这些 "私有" 变量并不是对象的私有属性, 但是可以通过构造函数所创建的对象方法去访问这些变量.让我们看看这种
 * 方式产生的有趣的副作用.
 */

/**
 * 2. 私有变量的警告
 * JavaScript从未阻止我么将一个对象中创建的属性复制给另一个对象. 例如,我们可以很容易地将清单5.11 中
 * 代码重写写成清单5.12所示的样子.
 * 
 * 清单5.12  通过函数访问私有变量, 而不是通过对象访问
 * 
 * 清单5.12将代码进行了修改,将ninja1的对象方法getFeints赋值给一个新的 imposter 对象. 然后,当我们通过对象impostor的 getFeints
 * 方法,可以测试是否可以访问ninja1对象的私有变量, 这样, 验证了我们是在假装这些是 "私有" 变量.如图 5.18所示.
 * 
 * 图5.18
 */

/**
 * 3. 回顾闭包和回调函数的例子
 * 回顾动画实例中,使用计时器的回调,这次,将对两个对象使用动画.
 * 
 * 清单5.13
 * 
 * 在本章开始部分, 我们使用闭包来简化单页面中的多个对象动画,现在来看看图 5.19 所示的词法环境.
 * 
 * 每次调用animateIt函数时,均会创建新的词法环境 1) 2), 该词法环境保存了动画所需的重要变量(elementId, elem, 动画元素, tick,
 * 计数次数, timer, 动画计数器的ID). 只要至少有一个通过闭包访问这些变量的函数存在, 这个环境就会一直保持.
 * 
 * 在本例中, 浏览器会一直保持 setInterval 的回调函数, 直到调用 clearInterval 方法. 随后, 当一个计时器到期,
 * 浏览器会调用对应的回调函数, 通过回调函数的闭包访问创建闭包时的变量. 这样避免了手动匹配回调函数的麻烦,并激活变量(3,4,5),
 * 极大地简化代码.
 */