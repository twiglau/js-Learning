/**
 * 闭包可以访问创建函数时所在作用域内的全部变量, 还介绍了几种闭包有用的方法. 例如,通过闭包模拟
 * 私有变量,通过回调函数使得代码更加优雅.
 * 
 * 闭包与作用域密切相关. 闭包对JavaScript的作用域规则产生了直接影响.
 */

/**
 * 1. 回顾使用闭包模拟私有变量的代码
 * 回顾以下私有变量的示例,这次,我们将关注执行上下文与词法环境. 查看清单5.11
 * 
 * 现在, 我们分析第一个Ninja对象创建完成之后程序的状态, 如图5.15所示, 我们可以利用标识符原理
 * 来更好地理解这种情况之下闭包的工作原理. JavaScript构造函数是通过关键字 new 调用的函数. 
 * 因此,每次调用构造函数时, 都会创建一个新的词法环境,该词法环境保持构造函数内部的局部变量.
 * 在本例中,创建了Ninja环境, 保持对变量 feints 的跟踪.
 * 
 * 此外,无论何时创建函数,都会保持词法环境的引用(通过内置 [[Environment]] 属性). 在本例中,
 * Ninja构造函数内部,我们创建了两个函数: getFeints 与 feint, 均有Ninja环境的引用,因为Ninja
 * 环境是这两个函数创建时所处的环境.
 * 
 * getFeints 与 feint 函数是新创建的 ninja 的对象方法(如前文所述,可通过this关键字访问).因此,
 * 可以在Ninja构造函数外部访问 getFeints 与 feint 函数, 这样实际上就创建了包含 feints 变量
 * 的闭包.
 * 
 * 当再创建一个Ninja的实例,即ninja2 对象时,将重复整个过程. 图5.16 显示了创建第二个Ninja
 * 对象之后的程序状态.
 * 
 * 每个通过Ninja构造函数创建的对象实例均获得了各自的方法 (ninja1.getFeints 与 ninja2.getFeints 是
 * 不同的), 当调用构造函数时, 各自的实例方法包含各自的变量. 这些 "私有变量" 只能通过构造函数内定义的
 * 对象方法进行访问, 不允许直接访问. 现在让我们看看当 ninja2.getFeints 方法调用时发生了什么.
 * 图5.17 显示了细节
 * 
 * 
 */