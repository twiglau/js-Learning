/**
 * 闭包允许函数访问并操作函数外部的变量. 只要变量或函数存在于声明函数时的作用域内,
 * 闭包即可使函数能过访问这些变量或函数.
 * 
 * 或许你已经熟悉了作用域的概念,但是,有时作用域指的是在程序的特定部分中标识符的可见性. 作用域是
 * 程序的一部分,特定的名字绑定特定的变量.
 * 
 * 这可能看起来很直观,但是要记住,所声明的函数可以声明之后的任何时间被调用,甚至当该函数声明的作用域
 * 消失之后仍然可以调用. 直接通过代码来解释这个概念是最好的. 但是在我们开始介绍如何优雅地实现动画,
 * 如何定义私有对象属性的具体示例之前,先从清单 5.1 中的简单示例开始
 * 
 * 在清单5.1中, 我们在同一作用域中声明了变量 outerValue 及外部函数 outerFunction -- 本例中,是
 * 全局作用域. 然后,执行外部函数 outerFunction.
 * 
 * 如图5.1所示, 该函数可以 "看见" 并访问变量outerValue,我们可能已经写过上百次这样的代码,但是却没有
 * 意识到其实我们正在创建一个闭包!
 * 
 * ==> 函数找到了隐藏在外部变量中 ninja
 * 
 * 外部变量 outerValue 和 外部函数 outerFunction 都是在全局作用域中声明的,该作用域(实际上就是一个闭包)
 * 从未消失(只要应用处于运行状态). 这也不足为奇,该函数可以访问到外部变量,因为它仍然在作用域内并且是可见的.
 * 
 * 虽然闭包存在,但是闭包的优势仍不明显. 接下来看 清单5.2的代码中加点料.
 * 
 * 仔细研究一下内部函数 innerFunction 中的代码,看看我们能否预测会发生什么?
 * - 第一个断言肯定会通过,因为外部变量 outerValue 在全局作用域内, 并且在任何地方都可见,但是第二个断言呢?
 * - 外部函数执行后,我们通过将内部函数的引用赋值给全局变量 later, 再通过 later 调用内部函数.
 * - 当内部函数执行时,外部函数的作用域已经不存在了,并且在通过later调用内部函数时,外部函数的作用域已不可见了
 * - 可以很好地遇见断言失败,因为内部变量innerValue肯定是undefined?
 * 
 * 清单 5.2 例子
 * 
 * 这怎么可能?是什么魔法使得在内部函数的作用域消失之后再执行内部函数时,其内部变量仍然存在呢?
 * 
 * 解释: 
 * 当在外部函数中声明内部函数时, 不仅定义了函数的声明,而且还创建了一个闭包. 该闭包不仅包含了函数
 * 的声明,还包含了在函数声明时该作用域中的所有变量. 当最终执行内部函数时,尽管声明时的作用域已经消失了,但是
 * 通过闭包,仍然能够访问到原始作用域,如图 5.3
 * 
 * 正如保护气泡一样,只要内部函数一直存在,内部函数的闭包就一直保存着该函数的作用域中的变量
 * 这就是闭包. 闭包创建了被定义时的作用域内的变量和函数的安全气泡, 因此函数获得了执行时所需的内容.
 * 该气泡与函数本身一起包含了函数和变量.
 * 
 * 虽然这些结构不容易看见(没有包含这么多信息的闭包对象可以进行观察),存储和引用这些信息会直接影响性能.
 * 谨记每一个通过闭包访问变量的函数都具有一个作用域链, 作用域链包含闭包的全部信息,这一点非常重要.因此,虽然闭包
 * 是非常有用的,但不能过度使用. 使用闭包时,所有的信息都会存储的内存中,直到JavaScript引擎确保这些信息不再使用
 * (可以安全地进行垃圾回收) 或页面卸载是,才会清理这些信息.
 */