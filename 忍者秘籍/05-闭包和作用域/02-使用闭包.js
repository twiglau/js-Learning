/**如何在JavaScript应用中使用闭包. 首先我们会关注闭包的实用性和优势 */

/**
 * 1. 封装私有变量
 * 许多编程语言使用私有变量,这些私有变量是对外隐藏的对象属性. 这是非常有用的一种特性,
 * 因为当通过其他代码访问这些变量时, 我们不希望对象的实现细节对用户造成过度负荷. 遗憾的是,原生
 * JavaScript不支持私有变量. 但是, 通过使用闭包,我们可以实现很接近的,可接受的私有变量.
 * 示例代码 5.3 所示
 * 
 * 在清单5.3中,创建了一个Ninja构造器. 在第3章中,我们已经介绍了使用函数作为构造器的概念(在第7章中我们
 * 还会进行深入介绍). 现在,知道如何使用构造器即可. 通过在函数上使用关键字new时,就会创建一个新的对象实例,
 * 此时调用构造函数,将新的对象作为它的上下文.所以,函数内的 this 将指向新的实例化对象.
 * 
 * 在构造器内部,我们定义了一个变量feints用于保存状态. 由于JavaScript的作用域规则的限制,因此只能在构造器内部
 * 访问该变量. 为了让作用域外部的代码能够访问该变量,我们定义了访问该变量的方法 getFeints. 该方法可以读取私有
 * 变量,但不能改写私有变量. (只读访问的方法通常称为 "getter")
 * function Ninja() {
 *    var feints = 0;
 *    this.getFeints = function(){
 *       return feints;
 *    };
 *    this.feint = function(){
 *       feints++;
 *    };
 * }
 * 
 * 接下来创建增量方法 feint, 用于控制私有变量的值. 在真实的应用程序中,该方法可能是一些业务逻辑的处理方法,但是在本例中,
 * 它只增加变量 feints 的值.
 * 
 * 在构造器完成了它的使命之后,新建ninja1 实例,并调用 ninja1 的实例方法 feint: 
 * var ninja1 = new Ninja();
 * ninja1.feint();
 * 
 * > 通过测试显示,我们可通过闭包内部方法获取私有变量的值, 但是不能直接访问私有变量. 这有效地阻止了读私有变量不可控的修改,
 * 这与真实的面向对象语言中的私有变量一样.
 * > 在构造器中隐藏变量,使其在外部作用域中不可访问,但是可在闭包内部进行访问
 * 
 * - 通过变量 ninja, 对象实例是可见的.
 * - 因为feint方法在闭包内部,因此可以访问变量 feints.
 * - 在闭包外部,我们无法访问变量 feints.
 * 
 * 通过使用闭包,可以通过方法对 ninja 的状态进行维护, 而不允许用户直接访问 --- 这是因为闭包内部的变量可以通过
 * 闭包内的方法访问,构造器外部的代码则不能访问闭包内部的变量.
 */


/**
 * 2. 回调函数
 * 处理回调函数是另一种常见的使用闭包的情景. 回调函数指的是需要在将来不确定的某一时刻异步调用的函数. 
 * 通常, 在这种回调函数中, 我们经常需要频繁地访问外部数据. 清单5.4示例.
 * 
 * 一个简单的动画计时器
 * 
 * 特别重要的是,在清单5.4的代码中使用了一个独立的匿名函数来完成目标元素的动画效果,该匿名函数作为计时器的一个
 * 参数传入计时器. 通过闭包,该匿名函数通过3个变量控制动画过程: elem, tick 和 timer. 这3个变量 ( elem 指的是
 * DOM元素的引用,tick指的是计数器和timer指的是计时器的引用) 用于维持整个动画的过程,且必须能够在全局作用域内访问到.
 * 
 * 但是,如果我们将这些变量从 animateIt 函数中移出到全局作用域, 动画仍然能够正常工作,为啥说不能污染全局作用域呢?
 * 
 * 我们开始把这些变量放到全局作用域内, 然后验证示例是否能够正常运行. 现在,修改示例代码,同时为两个元素设置动画,
 * 再添加一个具有唯一ID的元素. 在第一个动画调用之后,再将新的元素的ID传入 animateIt 方法进行调用.
 * 
 * 问题立刻就很显然了, 如果我们把变量放在全局作用域中,那么需要为每个动画分别设置 3 个变量, 否则同时用 3 个变量来跟踪
 * 多个不同动画的状态, 动画的状态就会发生冲突.
 * 
 * 通过在函数内部定义变量, 并基于闭包, 使得在计时器的回调函数中可以访问这些变量,每个动画都能够获的属于自己的 "气泡" 中
 * 的私有变量,如下 5.5 图
 * 
 * 如果没有闭包, 一次性同时做许多事情, 例如事件绑定,动画甚至服务端请求等, 都将会变得非常困难.
 * 
 * 清单5.4中的示例是能够演示闭包的概念的特别好的例子,也证明了通过闭包能够写出惊人的,简洁直观的代码. 通过将
 * 变量放置在 animateIt 函数内部, 不需要非常复杂的语法, 我们就可以创建一个默认的闭包.
 * 
 * 闭包内的函数不仅可以在创建的时刻访问这些变量, 而且当闭包内部的函数执行时, 还可以更新这些变量的值. 闭包不是在创建的那一时刻
 * 的状态的快照, 而是一个真实的状态封装, 只要闭包存在, 就可以对变量进行修改.
 * 
 * 闭包与作用域是强相关的.
 */