/**
 * JavaScript引擎是如何跟踪函数的执行并回到函数的位置的呢?
 * 在第2章中提到, JavaScript代码有两种类型: 一种是全局代码,在所有函数外部定义;
 * 一种是函数代码,位于函数内部. JavaScript引擎执行代码时, 每一条语句都处于特定
 * 的执行上下文中.
 * 
 * 既然具有两种类型的代码,那么就有两种执行上下文: 全局执行上下文和函数执行上下文. 二者
 * 最重要的差别是: 全局执行上下文只有一个, 当JavaScript程序开始执行时就已经创建了全局上下文;
 * 而函数执行上下文是在每次调用函数时, 就会创建一个新的.
 * 
 * > 第4章介绍了当调用函数时可通过关键字访问函数上下文. 函数执行上下文,虽然也称为上下文,但完全是
 * 不一样的概念. 执行上下文时内部的 JavaScript概念, JavaScript引擎使用执行上下文来跟踪函数的
 * 执行.
 * > 第2章介绍了 JavaScript基于单线程的执行模型: 在某个特定的时刻只能执行特定的代码. 一旦发生函数
 * 调用, 当前的执行上下文必须停止执行, 并创建新的函数执行上下文来执行函数. 当函数执行完成后,将函数执行
 * 上下文销毁, 并重新回到发生调用时的执行上下文中. 所以需要跟踪执行上下文 --- 正在执行的上下文以及
 * 正在等待的上下文. 最简单的跟踪方法是使用 执行上下文栈
 * (或称为调用栈)
 * 
 * 先查看 清单5.5 中代码
 * 
 * 通过这段基础代码,可以探索执行上下文是如何创建的,如图 5.6 所示.
 * 当执行清单5.5中的示例代码时,执行上下文的行为如下: 
 * >1. 每个JavaScript程序只创建一个全局执行上下文,并从全局执行上下文开始执行(在单页应用中每个页面只有一个
 * 全局执行上下文). 当执行全局代码时, 全局执行上下文处于活跃状态.
 * 
 * >2. 首先在全局代码中定义两个函数: skulk 和 report, 然后调用skulk("Kuma"). 由于在同一个特定时刻只能执行
 * 特定代码,所以JavaScript引擎停止执行全局代码,开始执行带有Kuma参数的 skulk 函数. 创建新的函数执行上下文,
 * 并置入执行上下文栈的顶部.
 * 
 * >3. skulk函数进而调用report函数. 又一次因为在同一个特定时刻只能执行特定代码,所以,暂停skulk执行上下文,创建
 * 新的Kuma作为参数的 report参数的执行上下文,并置入执行上下文栈的顶部.
 * 
 * >4. report通过内置函数console.log 打印出消息后, report函数执行完成, 代码又回到了skulk函数. report执行上
 * 下文从执行上下文栈顶部弹出, skulk函数执行上下文重新激活, skulk 函数继续执行.
 * 
 * >5. skulk函数执行完成后也发生类似的事情: skulk函数执行上下文从栈顶端弹出,从新激活一直在等待的全局执行上下文并回复执行.
 * JavaScript的全局代码恢复执行.
 * 
 * skulk函数第二次执行时,整个过程是类似的, 只是参数变成了Yoshi. 分别创建新的函数执行上下文skulk("Yoshi") 和 
 * report("Yosh skulking"),并依次置入执行上下文栈的顶部. 每个函数执行完成时,对应的函数上下文从执行上下文栈顶部弹出.
 * 
 * 执行上下文除了可以跟踪应用程序的执行位置之外,对于标识符也是至关重要,在静态环境中通过执行上下文可以准确定位标识符实际指
 * 向的变量.
 * 
 */