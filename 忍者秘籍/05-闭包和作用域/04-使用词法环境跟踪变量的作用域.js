/**
 * 词法环境 [Lexical environment] 是JavaScript引擎内部用来跟踪标识符与特定变量
 * 之间的映射关系,如下代码: 
 * 
 * var ninja = "Hattori";
 * console.log(ninja);
 * 
 * 当console.log 语句访问 ninja 变量时, 会进行词法环境的查询.
 * 注意: 
 * - 词法环境是JavaScript作用域的内部实现机制,人们通常称为作用域(scopes).
 * 
 * 通常来说, 词法环境与特定的JavaScript代码结构关联,即可以是一个函数, 一段代码片段,也可以是
 * try...catch语句. 这些代码结构(函数, 代码片段, try...catch) 可以具有独立的标识符映射表.
 * 
 * 注意: 
 * 在JavaScript的ES6初版中,词法环境只能与函数关联. 变量只存在于函数作用域中. 这也带来了一些混淆.
 * 因为JavaScript是一门类C的语言,从其他类C语言(如C++,C#,Java等)专享JavaScript的开发者通常会预期
 * 一些初级概念,例如 块级作用域.
 */

/**
 * 1. 代码嵌套
 * 词法环境主要基于代码嵌套,通过代码嵌套可以实现代码结构包含另一代码结构, 如图 5.8 多种代码嵌套类型.
 * 
 * 通过图5.8可以看出: 
 * > for循环嵌套在report函数中.
 * > report函数嵌套在skulk函数中.
 * > skulk函数嵌套在全局代码中.
 * 
 * 在作用域范围内,每次执行代码时, 代码结构都获得与之关联的词法环境. 例如,每次调用skulk函数,都将创建新
 * 的函数词法环境.
 * 
 * 此外,需要着重强调是, 内部代码结构可以访问外部代码结构中定义的变量. 
 * 例如: 
 * for循环可以访问report函数,skulk函数以及全局代码中的变量; report函数可以访问skulk函数以及全局代码
 * 中的变量; skulk函数可以访问的额外变量但仅是全局代码中的变量.
 * 
 * 以上这种访问变量的方式没有特殊之处. 但JavaScript引擎是如何跟踪这些变量?如何判断可访问性?
 * 这就是词法环境的作用.
 */

/**
 * 2. 代码嵌套与词法环境
 * 除了跟踪局部变量,函数声明,函数的参数和词法环境外,还有必要跟踪外部(父级)词法环境. 因为我们需要访问外部代码结构
 * 中的变量,如果在当前环境中无法找到某一标识符,就会对外部环境进行查找. 一旦查找到匹配的变量, 或是在全局环境中仍然
 * 无法查找到对应的标识符而返回错误,就会停止查找.
 * 
 * 图5.9中的示例显示: 
 * 当执行 report 函数时, 标识符intro,action及ninja是如何查找的. 在图5.9的示例中,在全局调用skulk函数,skulk函数又
 * 调用report函数.
 * 
 * 每个执行上下文都有一个与之关联的词法环境,词法环境中包含了在上下文中定义的标识符的映射表.例如,全局环境中具有 ninja 与
 * skulk的映射表, skulk环境中具有 action 与 report 的映射表, report 环境中具有 intro 的映射表(图5.9右侧).
 * 
 * 在特定的执行上下文中, 我们的程序不仅直接访问词法环境中定义的局部变量,而且还会访问外部环境中定义的变量. 例如, report
 * 函数体访问了在skulk函数中定义的 action 变量, 也访问了全局的 ninja 变量. 
 * 
 * 为了实现这一点,我们需要跟踪这些外部环境. JavaScript实现这一点得益于函数是第一型对象的特性.
 * 
 * 无论何时创建函数,都会创建一个与之相关联的词法环境,并存储在名为 [[Environment]]的内部属性上(也就是说
 * 无法直接访问 或 操作). 两个中括号用于标志内部属性. 在图5.9的示例中, skulk函数保存全局环境的引用, report函数保存
 * skulk环境的引用, 这些都是函数被创建时所在的环境.
 * 
 * 这些环境是在函数创建时决定的, 因此除了全局环境外, report函数还可以访问shulk环境.
 * 
 */

/**
 * 注意: 
 * 乍看之下会觉得奇怪. 为什么不直接跟踪整个执行上下文,直接搜索与环境相匹配的标识符映射表呢?
 * 从技术上来说,在本例中是可行的. 但是, 需要记住的是, JavaScript函数可以作为任意对象进行传递,定义函数时的环境
 * 与调用函数的环境往往是不同的(想一想闭包)
 */

/**
 * 无论何时调用函数,都会创建一个新的执行环境,被推入执行上下文栈. 此外,还会创建一个与之相关联的词法环境. 现在来看最重要的部分: 
 * 外部环境 与 新建的词法环境, JavaScript引擎将调用函数的内置 [[Environment]] 属性与创建函数时的环境进行关联.
 */