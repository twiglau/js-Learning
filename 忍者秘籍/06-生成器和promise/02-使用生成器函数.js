/**
 * 生成器函数几乎是一个完全崭新的函数类型, 它和标准的普通函数完全不同. 生成器(generator)
 * 函数能生成一组值的序列, 但每个值的生成是基于每次请求,并不同于标准函数那样立即生成. 我们
 * 必须显式地向生成器请求一个新的值,随后生成器要么响应一个新生成的值, 要么就告诉我们它之后都
 * 不会再生成新值. 更让人好奇的是, 每当生成器函数生成了一个值, 它都不会像普通函数一样停止执行.
 * 相反,生成器几乎从不挂起. 随后,当对另一个值的请求到来后,生成器就会从上次离开的位置恢复执行.
 * 
 * 清单6.1, 它使用生成器函数生成了一系列武器数据
 * 
 * 例子首先定义了一个生成器, 它能够生成一系列武器的数据. 创建一个生成器函数非常简单: 
 * 仅仅需要在关键字function后面加上一个星号(*). 这样一来生成器函数体内就能够使用新关键字yield,
 * 从而生成独立的值. 图6.1解释了yield的语法.
 * 
 * 调用生成器并不会执行生成器函数,相反,它会创建一个叫做迭代器(iterator)的对象.
 */

/**
 * 1. 通过迭代器对象控制生成器
 * 调用生成器函数不一定会执行生成器函数体. 通过创建迭代器对象,可以与生成器通信. 例如,可以通过迭代器对象
 * 请求满足条件的值. 稍微修改一下之前的示例,看看迭代器对象是如何工作的,如清单6.2所示.
 * 
 * 清单6.2 通过迭代器对象控制生成器
 * 
 * 如你所见, 调用生成器后, 就会创建一个迭代器(iterator): 
 * const weaponsIterator = WeaponGenerator();
 * 
 * 迭代器用于控制生成器的执行. 迭代器对象暴露的最基本接口是next方法. 这个方法可以用来向生成器请求一个值,从而
 * 控制生成器: 
 * const result1 = weaponsIterator.next();
 * 
 * next函数调用后,生成器就开始执行代码,当代码执行到yield关键字时, 就会生成一个中间结果(生成值序列中的一项),然
 * 后返回一个新对象,其中封装了结果值和一个指示完成的指示器.
 * 
 * 每当生成一个当前值后,生成器就会非阻塞地挂起执行,随后耐心等待下一次值请求的到达. 这是普通函数完全不具有的强大特性,
 * 后续的例子中它还会起到更大的作用.
 * 
 * 在本例中,第一次调用生成器的next方法让生成器代码执行到第一个yield表达式yield "Katana",然后返回了一个对象. 该
 * 对象的属性value的值置为katana, 属性done的值置为false, 表明之后还有值会生成.
 * 
 * 随后,通过再次调用 weaponIterator 的 next 方法, 再次向生成器请求另一个值: 
 * const result2 = weaponsIterator.next();
 * 
 * 该操作将生成器从挂起状态唤醒,中断执行的生成器从上次离开的位置继续执行代码, 直到再次遇到另一个中间值: yield "Wakizashi".
 * 随即生成了一个包含着值 Wakizashi 的对象,生成器挂起.
 * 
 * 1.1 对迭代器进行迭代
 * 通过调用生成器得到的迭代器,暴露出一个next方法能让我们向生成器请求一个新值. next方法返回一个携带着生成值的队形,而该对象
 * 中包含的另一个属性done也向我们指示了生成器是否还会追加生成值.
 * 
 * 现在,我们利用这一原理,试着用普通的 while 循环来迭代生成器生成的值序列,如清单6.3
 * 
 * 清单6.3, 使用while循环迭代生成器结果
 * 
 * 本例中,我们通过调用生成器函数再次创建了一个迭代器对象: 
 * const weaponsIterator = WeaponGenerator();
 * 
 * 我们还创建了一个变量item,用于保存由生成器生成的单个值. 随后, 我们给while循环指定了条件,该条件
 * 有点复杂需要分解来看: 
 * while(!(item = weaponsIterator.next()).done) {
 *    assert(item !== null, item.value)
 * }
 * 
 * 在每次迭代中, 我们通过调用迭代器 weaponsIterator 的next方法从生成器中取一个值,然后把值存放在item
 * 变量中. 和所有next返回的对象一样, item变量引用的对象中包含一个属性value为生成器返回的值, 一个属性
 * done指示生成器是否已经完成了值的生成. 如果生成器中的值没有生成完毕, 我们就会进入下次循环迭代,反之停止循环.
 * 
 * 这就是第一个生成器示例中 for-of 循环的原理. for-of循环不过是对迭代器进行迭代的语法糖.
 * for(var item of WeaponGenerator()){
 *    assert(item !== null, item);
 * }
 * 不同于手动调用迭代器的 next 方法, for-of循环同时还要查看生成器是否完成, 它在后台自动做了完全相同的工作.
 * 
 * 
 * 1.2 把执行权交给下一个生成器
 * 正如在标准函数中调用另一个标准函数, 我们需要把生成器的执行委托给另一个生成器. 让我们看
 * 清单6.4的例子, 生成器不仅生成了武器值也生成了 "忍者" 值.
 * 
 * 清单6.4  使用yield操作符将执行权交给另一个生成器
 * 
 * 执行这段代码后会输出 Sum Tzu, Hattori, Yoshi, Genghis Khan. 第一个输出Sun Tzu不会让你感到意外, 因为它就是
 * WarriorGenerator生成器得到的第一个值. 而对于第二个输出的值是Hattori.
 * 
 * 在迭代器上使用 yield*操作符, 程序会跳转到另外一个生成器上执行. 本例中, 程序从 WarriorGenerator跳转到一个新的
 * NinjaGenerator生成器上, 每次调用WarriorGenerator返回迭代器的next方法,都会使执行重新寻址到了NinjaGenerator上.
 * 该生成器会一直持有执行权直到无工作可做. 所以我们本例中生成Sun Tzu之后紧接的是Hattori 和 Yoshi. 仅当
 * NinjaGenerator的工作完成后, 调用原来的迭代器才会继续输出值 Genghis Khan. 注意, 对于调用最初的迭代器代码来说,这
 * 一切都是透明的. for-of 循环不会关心WarriorGenerator委托到另一个生成器上, 它只关心的done状态到来之前都一直调用
 * next方法.
 */

/**
 * 2. 使用生成器
 * 
 * 2.1 用生成器生成ID序列
 * 在创建某些对象时, 我们经常需要为每个对象赋一个唯一的ID值. 最简单的方式是通过一个全局的计数器变量,但这时一种丑陋的写法,
 * 因为这个计数器变量很容易就会不慎淹没在混乱的代码中,另外一种方式则是使用生成器
 * 
 * 如清单6.5所示
 * 
 * 本例开始的迭代器中包含一个局部变量id, 其代表了ID计数器. 局部变量id仅能在该生成器中被访问,故而完全不必担心有人会不小心在代码
 * 的其他地方修改id值. 随后是一个无限的while循环, 其每次迭代都能生成一个新id值并挂起执行,知道下一次ID请求到达: 
 * function *IdGenerator(){
 *    let id = 0;
 *    while(true){
 *       yield ++id;
 *    }
 * }
 * 
 * 注意: 
 * 标准函数中一般不应该书写无限循环的代码. 但在生成器中没问题! 当生成器遇到了一个yield语句, 它就会一直挂起执行直到
 * 下次调用next方法, 所以只有每次调用一次next方法, while循环才会迭代一次并返回下一个ID值.
 * 
 * 定义了生成器之后,又创建了一个迭代器对象: 
 * const idIterator = IdGenerator();
 * 
 * 我们能够调用 idIterator.next() 方法来控制生成器执行. 每当遇到一次 yield语句生成器就会停止执行, 返回一个新的ID值可以用于
 * 给我们的对象赋值: 
 * const ninja1 = { id: idIterator.next().value };
 * 看到这个方法多么简单了吧? 代码中没有任何会被不小心修改的全局变量. 相反, 我们使用迭代器从生成器中请求值. 另外,如果还需要
 * 用另外一个迭代器来记录ID序列, 例如迭代器samurai, 我们只需要直接再初始化一个新迭代器就可以了.
 * 
 * 
 * 2.2 使用迭代器遍历DOM树
 * 网页的布局是基于DOM结构的, 它是由HTML节点组成的树形结构, 除了根节点的每个节点都只有一个父节点,而且可以有0个或多个孩子节点.
 * 由于DOM是网页开发中的基础,所以我们大部分代码都是围绕着对它的遍历. 遍历DOM的相对简单的方式就是实现一个递归函数,
 * 在每次访问节点的时候都会被执行.
 * 
 * 清单6.6 递归遍历DOM
 * 
 * 这个例子使用一个递归函数来遍历id为subtree的所有节点, 在访问每个节点的过程中我们还记录了该节点的类型. 本例中分别输出了
 * DIV, FORM, INPUT, P 和 SPAN.
 * 
 * 很久依赖我们都在编写这种DOM遍历代码,它一直能满足我们的需要,但现在我们可以使用生成器,故而可以换一种方式来实现它,
 * 
 * 清单6.7  用生成器遍历 DOM 树
 * 
 * 这个清单展示了我们可以通过生成器实现DOM遍历,就像标准递归一样简单,但它不必书写丑陋的回调函数代码. 不同于在下一层递归处理
 * 每个访问过的节点子树, 我们为每个访问过的节点创建了一个生成器并将执行权交给它,从而使我们能够以迭代的方式书写概念上递归的代码.
 * 它的好处在于我们能够不凭借讨厌的回调函数, 仅仅以一个简单的 for-of 循环就能处理生成的节点.
 * 
 * 这个案例是一个相当好的例子,因为它还告诉了我们如何在不必使用回调函数的情况下, 使用生成器函数来解耦代码,从而将生产值(比例中
 * 是HTML节点) 的代码和消费值(本例中的 for-of 循环打印, 访问过的节点 ) 的代码分割开. 除此之外,在很多场景下, 使用迭代器比使用
 * 递归都要自然,所以保持一个开放的思路很重要.
 */


/**
 * 3. 与生成器交互
 * 从目前已经展示的例子来看,你已经看到了如何通过使用yield表达式从生成器中返回多个值. 但生成器远比这强大! 我们还能向生成器发送值,
 * 从而实现双向通信! 使用生成器我们能够生成中间结果,在生成器以外我们也能够使用该结果进行任何什么操作,然后,一旦准备好了,
 * 就能够把整个新计算得到的数据再完完全全返回给生成器.
 * 
 * 3.1 作为生成器函数参数发送值
 * 向生成器发送值的最简方法如其他函数一样,调用函数并传入实参.
 * 
 * 清单6.8, 向生成器发送数据及从生成器接收数据
 * 
 * 3.1.1 使用next方法向生成器发送值
 * 除了在第一次调用生成器的时候向生成器提供数据, 我们还能通过next方法向生成器传入参数. 在这个过程中,我们把生成器函数从挂起状态恢复到了执行
 * 状态. 生成器把这个传入的值用于整个yield表达式(生成器当前挂起的表达式) 的值,
 * 
 * 如图6.3所示.
 * 
 * 这个例子中我们调用了两次 ninjaIterator的next方法. 第一次调用ninjaIterator.next(),请求了生成器的第一个值. 由于生成器还没开始执行,
 * 这次调用则启动了生成器,对表达式 "Hattori " + action 进行求值, 得到了值 "Hattori skulk",并将该生成器的执行挂起.
 * 这一点没什么特别的, 类似的事情我们已经做过很多次了.
 * 
 * 然而第二次调用ninjaIterator的next方法则发生了有趣的事: 
 * ninjaIterator.next("Hanzo"). 这一次, 我们使用next方法将计算得到的值又传递回生成器. 
 * 生成器函数耐心地等待着, 在表达式yield("Hattori " + action)位置挂起, 故而值Hanzo作为参数传入了next()方法,
 * 并用作整个yield表达式的值. 本例中,也就是表示语句 imposter = yield("Hattori " + action)中的变量 imposter
 * 最终值为 Hanzo.
 * 
 * 以上展示了如何在生成器中双向通信. 我们通过 yield 语句从生成器中返回值, 再使用迭代器的 next() 方法把值传回生成器.
 * 
 * 注意: 
 * next方法为等待中的yield表达式提供了值, 所以,如果没有等待中的 yield 表达式, 也就没有什么值能应用的. 
 * 基于这个原因, 我们无法通过第一次调用 next 方法来向生成器提供该值.但记住,如果你需要为生成器提供一个初始值,你可以调用
 * 生成器自身, 就像 NinjaGenerator("skulk").
 * 
 * 
 * 3.1.2 抛出异常
 * 还有一种稍微不那么正统的方式将值应用到生成器上: 通过抛出一个异常. 每个迭代器除了有一个 next 方法, 还有一个 throw 方法.
 * 
 * 清单 6.9  向生成器抛出异常
 * 
 */

/**
 * 4. 探索生成器内部构成
 * 我们已经知道了调用一个生成器不会实际执行它. 相反, 它创建了一个新的迭代器, 通过该迭代器我们才能从生成器中请求值. 在生成器
 * 生成(或让渡)了一个值后, 生成器会挂起执行并等待下一个请求的到来. 在某种方面来说, 生成器的工作更像是一个小程序, 一个在状
 * 态中运动的状态机.
 * - 挂起开始 -- 创建了一个生成器后, 它最先以这种状态开始. 其中的任何代码都未执行.
 * - 执行 -- 生成器中的代码执行的状态. 执行要么是刚开始,要么是从上次挂起的时候继续的. 当生成器对应的迭代器调用了next方法,并且
 * 当前存在可执行的代码时, 生成器都会转移到这个状态.
 * - 挂起让渡 -- 当生成器在执行过程中遇到了一个 yield 表达式, 它会创建一个包含着返回值的新对象,随后再挂起执行. 生成器在这个
 * 状态暂停并等待继续执行.
 * - 完成 -- 在生成器执行期间, 如果代码执行到 return 语句 或者 全部代码执行完毕,生成器就进入该状态.
 * 
 * 生成器是如何跟随执行环境上下文的, 如图6.5 所示.
 * 
 * 4.1 通过执行上下文跟踪生成器函数
 * 在前面的例子中,我们介绍了执行环境上下文. 它是一个用于跟踪函数的执行的JavaScript内部机制. 尽管有些特别,生成器依然是一种函数,所以
 * 让我们仔细看看它们和执行环境上下文之间的关系
 * 
 * function *NinjaGenerator(action){
 *    yield "Hattori " + action;
 *    return "Yoshi " + action;
 * }
 * 
 * const ninjaIterator = NinjaGenerator("skulk");
 * const result1 = ninjaIterator.next();
 * const result2 = ninjaIterator.next();
 * 
 * 这里我们对生成器进行了重用,其生成了两个值: Hattori skulk 和 Yoshi skulk.
 * 
 * 现在, 我们将探索应用的状态, 看一看在应用执行过程中不同位置上的执行上下文栈. 图6.6中展示了应用执行中两个位置
 * 的状态快照.
 * 
 * 第一个快照显示了应用在调用NinjaGenerator函数之前的应用执行状态.
 * 由于正在执行的是全局代码,故执行上下文栈仅仅包含全局执行上下文, 该上下文引用了当前标识符所在的全局环境. 而NinjaGenerator
 * 则仅仅引用了一个函数, 此时其他标识符的值都是 Undefined.
 * 
 * 图6.6
 * 
 * 当我们调用NinjaGenerator函数: 
 * const ninjaIterator = NinjaGenerator("skulk");
 * 控制流进入了生成器,正如进入任何其他函数一样, 当前将会创建一个新的函数环境上下文NinjaGenerator(和相对应的词法字典并列),并将
 * 该上下文入栈. 而生成器比较特殊,它不会执行任何函数代码. 取而代之则生成一个新的迭代器再从中返回, 通过在代码中用 ninjaIterator
 * 可以来引用这个迭代器. 由于迭代器是用来控制生成器的执行的, 故而迭代器中保存着一个在它创建位置处的执行上下文.
 * 
 * 如图6.7所示, 当程序从生成器中执行完毕后, 发生了一个有趣的现象. 一般情况下, 当程序从一个标准函数返回后, 对应的执行环境上下文会
 * 从栈中弹出, 并被完成地销毁. 但在生成器中不是这样.
 * 
 * 相对应的NinjaGenerator会从栈中弹出, 但由于ninjaIterator还保存这对它的引用, 所以它不会被销毁. 你可以把它看作一种类似闭包的事物.
 * 在闭包中国, 为了在闭包创建的时候保证变量都可用, 所以函数会对创建它的环境持有一个引用. 以这种方式, 我们能保证只要函数还存在,环境及
 * 变量就都存在着. 生成器, 从另一个角度看, 还必须恢复执行. 由于所有函数的执行都被执行上下文所控制,故而迭代器保持了一个对当前执行环境
 * 的引用,保证只要迭代器还需要它的时候它都存在.
 * 
 * 当调用迭代器的 next方法时发生了另一件有趣的事: 
 * const result1 = ninjaIterator.next();
 * 
 * 如果这只是一个普通的函数调用, 这个语句会创建一个新的next()的执行环境上下文项,并放入栈中. 但你可能注意到了, 生成器绝不标准, 对next
 * 方法调用的表现也很不同. 它会重新激活对应的执行上下文. 在这个例子中, 是NinjaGenerator上下文, 并把该上下文放入栈的顶部,从它上次离开
 * 的地方继续执行.
 * 
 * 如图6.8所示.
 * 
 * 图6.8阐述了函数和生成器之间的关键不同. 标准函数仅仅会被重复调用, 每次调用都会创建一个新的执行环境上下文. 相比之下, 生成器的执行环境
 * 上下文则会暂时挂起并在将来恢复.
 * 
 * 在我们的例子中, 由于是第一次调用next方法,而生成器之前并没执行过,所以生成器开始执行并进入执行状态. 当生成器函数运行到这个位置的时候,又
 * 会发生一件有趣的事: 
 * yield "Hattori " + action
 * 
 * 生成器函数运行得到的表达式的结果为 Hattori skulk, 然后执行中又遇到了 yield 关键字. 这种情况表明了Hattori skulk是该生成器的第一个
 * 中间值, 所以需要挂起生成器的执行并返回该值. 从应用状态的角度来看, 发生了一件类似前面的事情: NinjaGenerator上下文离开了调用栈, 但由于
 * ninjaIterator还持有着对它的引用, 故而它并未被销毁. 仙子阿生成器挂起了, 又在非阻塞的情况下移动到了挂起让渡状态.程序在全局代码中恢复执行,
 * 并将生产出的值存入变量 result1. 应用的当前状态
 * 
 * 如图6.9所示.
 * 
 * 当遇到另一个迭代器调用时, 代码继续执行: 
 * const result2 = ninjaIterator.next();
 * 
 * 在这个位置, 我们又把整个流程走了一遍: 
 * 首先通过ninjaIterator激活NinjaGenerator的上下文引用, 将其入栈, 在上次离开的位置继续执行. 本例中, 生成器计算表达式 "Yoshi " + action. 
 * 但这一次没再遇到 yield 表达式, 而是遇到了一个return语句. 这个语句会返回值 Yoshi skulk 并结束生成器的执行,随之生成器进入结束状态.
 * 
 * 看,这很强大, 我们深入挖掘生成器的工作原理后可以发现, 生成器所有不可思议的特点实际都来源于一点: 
 * 即当我们从生成器中取得控制权后, 生成器的执行环境上下文一直是保存的, 而不是像标准函数一样退出后销毁.
 */
