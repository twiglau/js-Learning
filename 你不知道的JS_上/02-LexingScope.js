//欺骗词法
//1.eval
//在执行eval(...)之后的代码时,引擎并不"知道" 或 "在意" 前面的代码是以动态形式
//插入进来,并对词法作用域的环境进行修改的. 引擎只会如往常进行词法作用域查找.

// function foo(str, a) {
//     eval(str); //欺骗!
//     console.log(a,b);
// }
// var b = 2;
// foo("var b = 3;",1) //1,3

/**
 * eval(...)调用中的"var b = 3;" 这段代码会被当做本来就在那里一样来处理. 
 * 由于那段代码声明一个新的变量b,因此它对已经存在的foo(...)的词法作用域进行了
 * 修改. 事实上,和前面提到的原理一样,这段代码实际上在foo(...)内部创建了一个变量b,
 * 并遮蔽了外部(全局)作用域中同名变量.
 * 
 * 当console.log(...)被执行时,会在foo(...)的内部同时找到 a 和 b,但是永远
 * 也无法找到外部的b, 因此会输出 "1, 3"
 */

/**
 * 在严格模式中,eval(...)在运行时有其自己的词法作用域,意味着其中的声明
 * 无法修改所在的作用域.
 */
// function foo_01(str) {
//     "use strict";
//     eval(str);
//     console.log(a); // ReferenceError: a is not defined
// }
// foo_01("var a = 2");

//2.欺骗词法作用域 with 关键字
//  with通常被当做重复引用同一个对象中的多个属性的快捷方式,可以不需要重复引用
//  对象本身.

// var obj = {
//     a:1,
//     b:2,
//     c:3
// };

// // 单调乏味的重复 "obj"
// obj.a = 2;
// obj.b = 3;
// obj.c = 4;

// // 简单的快捷方式 --> 方便地访问对象属性.
// with(obj) {
//     a = 3;
//     b = 4;
//     c = 5;
// }

function foo_02(obj){
    with(obj){
        a = 2;
    }
}
var o1 = {
    a: 3
}
var o2 = {
    b: 3
}
foo_02(o1);
console.log(o1.a); //2

foo_02(o2);
console.log(o2.a); // undefined
console.log(a); // 2 ----不好, a 被泄露到全局作用域上了!
// with 可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域,
// 因此这个对象的属性也会被处理为定义在这个作用域中的词法标识符.

/**
 * 1.尽管 with 块可以将一个对象处理为词法作用域,但是这个块内部正常的 var 声明
 * 并不会被限制在这个块的作用域中,而是被添加到with所处的函数作用域中.
 * 2.with声明实际上是根据你传递给它的对象凭空创建了一个全新的词法作用域.
 * 3. o2的作用域,foo(...)的作用域和全局作用域中都没有找到标识符a,因此当a = 2
 *   执行时, 自动创建了一个全局变量(因为是非严格模式)
 */
