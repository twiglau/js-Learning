/**
 * 1.考虑以下代码
 */
// a = 2;
// var a;
// console.log(a); // 输出结果为 2

/**
 * 2.对比以下代码
 */
// console.log(b); //undefined
// var b = 2;

// 变量和函数在内的所有生命都会在任何代码被执行前首先被处理
// 关于 var a = 2 的解释:
// JavaScript 实际上会将其看成两个声明: var a; 和 a = 2;
// 第一个定义是在编译阶段进行的. 第二个赋值声明会被留在原地执行阶段.


//对于1. 的代码的解释
/**
 * var a;
 * a = 2;
 * console.log(a);
 * 
 * 第一部分是编译, 而第二部分是执行
 */

//对于2. 的代码的解释
/**
 * var b;
 * console.log(b);
 * b = 2;
 */

// 以上过程就好像变量和函数声明从它们在代码中出现的位置被
// "移动"到了最上面. 这个过程就叫做 提升.
// 只有声明本身会被提升, 而赋值或其他运行逻辑会留在原地,如果提升改变了代码执行
// 的顺序,会造成非常严重的破坏


//3.函数优先
/**
 * 函数声明和变量声明都会被提升,但是一个值得注意的细节(这个细节可以出现在有多个
 * "重复"声明的代码中)是函数会首先被提升,然后才是变量.
 */

foo();
var foo;

function foo(){
    console.log(1);
}
foo = function(){
    console.log(2);
}

//以上代码片段会被引擎理解为如下形式:
function foo(){
    console.log(1);
}
foo();//1

foo = function(){
    console.log(2);
}
//注意: var foo 尽管出现在 function foo()...声明之前,但它是重复的声明
//(因此被忽略),因为函数声明会被提升的普通变量之前.
// 尽管重复的var 声明会被忽略掉,但出现在后面的函数声明还是可以覆盖前面
