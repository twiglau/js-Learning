/**
 * 关于闭包:
 * 当函数可以记住并访问所在的词法作用域时,就产生了闭包,即使函数是在当前词法作用域之外执行
 */

//查看一下代码
function foo(){
    var a = 2;
    function bar(){
        console.log( a );//2
    }
    bar();
}
foo();

//基于词法作用域的查找规则,函数bar()可以访问作用域的变量 a (这个例子中的是一个RHS引用查询)
//问题: 这个闭包吗?
//准确解释:
//bar()对a 的引用的方法是词法作用域的查找规则,而这些规则只是闭包的一部分[却非常重要]

//以下代码,清晰地展示了闭包:
function foo(){
    var a = 2;
    function bar(){
        console.log(a);
    }
    return bar;
}
var baz = foo();
baz(); // 2 --这就是闭包效果

//函数bar()的词法作用域能够访问foo()的内部作用域.然后我们将bar()函数本身当做一个值类型进行
//传递.在这个例子中,我们将bar 所引用的函数对象本身当做返回值

/**
 * 在foo()执行后,其返回值(也就是内部的bar()函数)赋值给变量baz并调用baz(),实际上只是通过
 * 不同的标识符引用调用了内部的函数bar().
 * 
 * 特点:bar()显然可以被正常执行,但是在这个例子中,它在自己定义的词法作用域以外的地方执行.
 * 
 * 在foo()执行后,通常会期待foo()的整个内部作用域都被销毁,因为我们知道引擎有垃圾回收器用来
 * 释放不再使用的内存空间,而""闭包"的神奇之处 正式可以阻止这件事情的发生.
 * 事实上内部作用
 */
